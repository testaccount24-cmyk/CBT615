./ ADD NAME=$DOC     0100-03065-03065-2223-00179-00179-00000-DYNALLC

  DYNAMIC ALLOCATION MACROS


  MACROS (ALLOC FREE)

  NAME     ALLOC DUMMY,PERM,DSN=,DDN=,DDNRET=,MEMBER=,DISP=,
                 WAITDSN=NO,WAITUNIT=NO,WAITVOL=NO,
                 VOL=,UNIT=,SYSOUT=,FREE=,COPIES=,LABEL=,
                 BLKSIZE=,DEN=,DSORG=,KEYLEN=,LRECL=,RECFM=,
                 PASWORD=,DSNRET=,MF=AUTO,PREFIX=,ERROR=,
                 SPACE=,F=,FILE=,DA=,QNAME=,DSORGRT=,
                 VOLRET=,DCBDSN=,DCBDDN=,SPECIAL=,DDNTO=,
                 FCB=,
                 DEFER=,UNITCNT=,
                 FORMS=,DEST=,SSREQ=,FORUSER=,TU=,DSNPDE=


  NAME     FREE  UNALC,DSN=,DDN=,MEMBER=,DISP=,SYSOUT=,
                 ERROR=,MF=AUTO,PREFIX=,FILE=,F=,DA=,HOLD=


  NAME     DYNSPACE TYPE


  DOCUMENTATION

  This  macro provides a dynamic allocation function by build-
  ing a dynamic allocation parameter list and invoking SVC 99.

  It first sets up a workarea environment  for  the  parameter
  list  and then tests the keywords supplied and invokes inner
  macros to build the text units. The inner macros  themselves
  use inner macros to update global variables, store text unit
  pointers  etc  there  are  three ways of specifying the work
  area address.

  A) MF=AUTO, MF=G, MF=(E,address,lnthsymb).
  In the first form, an inner macro DYNSPACE is called to name
  a work area, the name being returned in the global SETC var-
  iable &DYNSP. A DSECT is created to  map  this  area.    The
  global variables &dtuo (text unit offset counter) and &DTUPO
  (text  unit  pointer  offset  accumulator)  are set to zero.
  These accumulators are updated as each text  unit  processor
  aquires  storage.  After all text units have been built, the
  amount of space used is calculated, and the  DYNSPACE  macro
  is then called again to log the amount needed. DYNSPACE Sets
  a global variable &DYNSPQ to the highest amount any ALLOC or
  FREE  macro  requested,  and when called with the expand op-
  tion, (no operands or name field supplied), expands  into  a
  ds for that quantity. (See DYNSPACE)

  MF=G  specifies  that  the ALLOC macro enter the begin macro
  workarea to acquire the storage necessary. It does this  via
  the RCPDS macro. (See RCPDS). However, if the ALLOC macro is
  called several times with this option, a lot of storage will
  be  used  up,  as the storage will not be shared. Thus, this
  form should only be used if the ALLOC/FREE macro is only  to
  be used once or twice during an assembly.

  MF=E causes the macro to use a user specified work area. The
  second  parameter gives the name of the workarea, and an op-
  tional third parameter is the name of a symbol to be equated
  to the length of the required work area.

  Dynamic allocation functions are similar to those  available
  with  JCL, using the same keywords. However, certain formats
  are slightly different. For instance, certain  keywords  can
  have  varying  parameters,  eg  dataset name, DDNAME, VOLSER
  etc.  Provision is made for both variable specification.  In
  the absolute form, the parameter is entered in quotes,
  ex.    ALLOC DSN='SYS1.LINKLIB',DISP=SHR
  however, this name remains fixed for the assembly.   In  the
  variable  format,  the  address  of  a locator is specified,
  where the locator consists of a six byte field, the first  4
  bytes  of  which  point to the parameter, while the next two
  contain the length.

  ex.         ALLOC DSN=LOCATOR
     LOCATOR  DC    A(dsn),Y(12)
     DSN      DC    C'SYS1.LINKLIB'

  Numeric quantities e.g. COPIES= for  sysout,  should  either
  specify  a  numeric  value, COPIES=3, a value in a register,
  COPIES=(r3), or the  name  off  a  fullword  containing  the
  value,  COPIES=numcopys,  where  numcopys  is  the name of a
  fullword field.

  Other keywords such as DISP=  can  only  have  the  absolute
  form, and values should not be entered within quotes.  Addi-
  tional  facilities  not available with JCL are the return by
  the system of information on the dataset, eg DSORG. This  is
  done  by specifying DSORGRT=symbol, where symbol is a symbol
  which will be equated to a two  byte  field  containing  the
  DSORG type (see Job Management, Supervisor and TSO).

  The  system  can  also generate and return a DDNAME. This is
  carried out  by  entering  DDNTO=(addr1,addr2,,...)    Where
  addr1,addr2  etc are the names of 8 byte fields which are to
  receive the DDNAME.

  Note that WAITDSN=YES, WAITVOL=YES or  WAITUNIT=YES  require
  that  the  program  be  APF authorized, or in Key 0-7, or in
  supervisor state.

  For  further information on dynamic allocation, see Job Man-
  agement, Supervisor and TSO SPL's.


  DYNSPACE

  This is an inner macro to ALLOC/FREE.  It is called to:

  1.  Log the various amounts needed by each, remembering  the
      largest.

  2.  Generating a DS for the largest amount.

  The  first  two  functions  are invoked by ALLOC/FREE macros
  only, and the third is used by the  programmer,  either  ex-
  plicitly, or by BEGINWKA, if the latter is used.

  To invoke the naming function, ALLOC/FREE generate:

  name DYNSPACE

  Note.  The  naming  operation  only  generates a name on the
  first call in the assembly. The name remains the same  until
  DYNSPACE is called to expand into a DS.

  The second function is invoked by the macro call
       DYNSPACE ADD

  (no name field and one operand) it uses the global variables
  &dtuo  and  &DTUPO  to calculate the space for this request,
  and updates &DYNSPQ only if the current  request  is  for  a
  greater amount

  The  third  function  is invoked by calling DYNSPACE with no
  name or operand field.

  This expands into a define storage, clears the DYNSPACE name
  global SETC, and the &DYNSPQ GLOBAL SETA.   Thus, the  macro
  is serially reusable in all functions.

  S99FAIL

  S99FAIL  macro  will  invoke the dynamic allocation (SVC 99)
  error message display routine.


  EXAMPLES

           ALLOC DUMMY,DDN=DDNAME
           ALLOC DDN=DDNAME,DSN=DSNAME,DISP=SHR
           FREE  DDN=DDNAME
           ALLOC DDN=DDNAME,UNIT=UNITADDR
           S99FAIL

           data areas

           DYNSPACE
                    SPACE
           UNITADDR DC    A(UNIT)
           UNITL    DC    Y(3)
           UNIT     DC    CL3' '
                    SPACE
           DDNAME   DC    A(DDN)
           DDNL     DC    Y(8)
           DDN      DC    CL8' '
                    SPACE
           DSNAME   DC    A(DSN)
           DSNL     DC    Y(44)
           DSN      DC    CL44' '

         These are required as mapping for the above macros:

           IEFZB4D0
           IEFZB4D2
./ ADD NAME=ALLOC    0100-03065-03065-2223-00340-00340-00000-DYNALLC
         MACRO
&NAME    ALLOC &DUMMY,&PERM,                                           X
               &WAITDSN=NO,&WAITVOL=NO,&WAITUNIT=NO,                   X
               &DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,                   X
               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X
               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X
               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X
               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X
               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,&TERM=,    X
               &FCB=,                                                  X
               &CHARS=,                                     *LBD 11/88*X
               &DEFER=,                                    *LBD 03/86* X
               &UNITCNT=,                                  *LBD 06/86* X
               &OUTDES=,                                    *LBD 11/88*X
               &MGMTCLAS=,                                 *LBD-08MAY96X
               &STORCLAS=,                                 *LBD-08MAY96X
               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=,&MSVGP=
.**********************************************************************
.*                                                                    *
.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *
.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *
.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *
.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *
.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *
.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *
.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *
.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *
.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *
.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *
.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *
.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *
.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *
.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *
.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *
.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *
.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *
.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *
.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *
.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *
.*    THAT QUANTITY. (SEE DYNSPACE)                                   *
.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *
.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *
.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *
.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *
.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *
.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *
.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *
.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *
.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *
.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *
.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *
.*                                                                    *
.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *
.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *
.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *
.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *
.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *
.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *
.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *
.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *
.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *
.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *
.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *
.*    CONTAIN THE LENGTH.                                            *
.*    EG          ALLOC DSN=LOCATOR                                  *
.*       LOCATOR  DC    A(DSN),Y(12)                                 *
.*       DSN      DC    C'SYS1.LINKLIB'                              *
.*                                                                   *
.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *
.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *
.*       A VALUE IN A REGISTER, COPIES=(R3),                         *
.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *
.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *
.*       FULLWORD FIELD.                                             *
.*                                                                   *
.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *
.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *
.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *
.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *
.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *
.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *
.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *
.*       SUPERVISOR AND TSO).                                        *
.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *
.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *
.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *
.*       ARE TO RECEIVE THE DDNAME.                                  *
.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *
.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *
.*                                                                   *
.**********************************************************************
.*  MODIFIED 08/25/82 TO ADD MSVGP SUPPORT .                         *
.*  MODIFIED 09/10/82 TO ADD TERM  SUPPORT .                         *
.*  MODIFIED 10/27/83 TO:                                            *
.*             ADD WAITVOL TO WAIT FOR VOLUME TO BE MOUNTED.         *
.*             ADD WAITDSN TO WAIT FOR DSN TO BECOME AVAILABLE.      *
.*             ADD WAITUNIT TO WAIT FOR UNIT TO BECOME AVAILABLE.    *
.*             **  THESE THREE OPTIONS ARE VALID ONLY IF THE USER    *
.*             **  IS AN AUTHORIZED PROGRAM                          *
.*                   LIONEL DYCK/ROCKWELL INT'L  (213) 594-1647      *
.* MODIFIED 03/31/86 TO ADD DEFER SUPPORT.                 *LBD 03/86*
.*                   LIONEL DYCK/ROCKWELL INT'L  (213) 594-1125      *
.**********************************************************************
         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO
         GBLA  &DTUO              OFFSET TO TEXT UNITS
         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS
         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS
         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL
         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC
         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS
         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS
         LCLA  &I                 COUNTER
         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E
         LCLC  &C,&T,&PAR
.*
.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,
&RCPS99(1)     SETB           1
&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER
&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX
&NAME    DS    0H
         AIF   ('&PREFIX' EQ '').TMF
         AIF   (K'&PREFIX LT 4).POK
         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'
&DYNP    SETC  '&PREFIX'(1,4)
         AGO   .TMF
.POK     ANOP
&DYNP    SETC  '&PREFIX'
.TMF     AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF' NE 'AUTO').TMFE
NAME     DYNSPACE             GET NAME FOR SPACE
         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST
         USING &DYNP.DS,R1             USE GENERATED DSECT
&T       SETC  'A'
&PAR     SETC  '&DYNSP+4'
&DSECT   SETB  1
         AGO   .START
.TMFE    AIF   ('&MF(2)' NE '').E2OK
         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'
         AGO   .GEN
.E2OK    ANOP
&DSECT   SETB  1
         AIF   ('&MF(2)' EQ '(').RMFE
         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START
         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS
         AGO   .START
.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP
.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB
         USING S99RB,R15
         ST    R15,0(R1)               AND STORE IN RB POINTER
         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST
         MVI   S99RBLN,20              MOVE IN LIST LENGTH
         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE
         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS
         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB
         AIF   ('&WAITDSN' EQ 'NO').NWD
         OI    S99FLG21,S99WTDSN       SET WAIT FOR DSN FLAG
.NWD     AIF   ('&WAITVOL' EQ 'NO').NWV
         OI    S99FLG21,S99WTVOL       SET WAIT FOR VOLUME
.NWV     AIF   ('&WAITUNIT' EQ 'NO').NWU
         OI    S99FLG21,S99WTUNT       SET WAIT FOR UNIT
.NWU     ANOP
         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS
         USING S99TUNIT,R15
&DTUO    SETA  0
&DTUPO   SETA  0
         AIF   ('&SSREQ' EQ 'YES').SSREQ
.TDSN    AIF   ('&DSN&DA' NE '').DSN
         AIF   ('&DSNPDE' NE '').DSNPDE
         AIF   ('&DSNRET' NE '').DSNRT
         AIF   ('&SYSOUT' NE '').SYSOUT
         AIF   ('&DUMMY' NE '').DUMMY
         AIF   ('&QNAME' NE '').QNAME
.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN
         AIF   ('&DDNRET&DDNTO' NE '').DDNRT
.TMCLAS  AIF   ('&MGMTCLAS' NE '').MCLAS                   *LBD-08MAY96
.TSCLAS  AIF   ('&STORCLAS' NE '').SCLAS                   *LBD-08MAY96
.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT
.TDEFER  AIF   ('&DEFER' EQ 'YES').DEFER                   *LBD 03/86*
.TVOLRET AIF   ('&VOLRET' NE '').VOLRET
.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT
.TLABEL  AIF   ('&LABEL' NE '').LABEL
.TPSWD   AIF   ('&PASWORD' NE '').PASWORD
.TFORUSE AIF   ('&FORUSER' NE '').FORUSER
.TTU     AIF   ('&TU' NE '').TU
.TDISP   AIF   ('&DISP' NE '').DISP
.TSPACE  AIF   ('&SPACE' NE '').SPACE
.TLRECL  AIF   ('&LRECL' NE '').DCB
         AIF   ('&DEN' NE '').DCB
         AIF   ('&RECFM' NE '').DCB
         AIF   ('&BLKSIZE' NE '').DCB
         AIF   ('&DSORG' NE '').DCB
         AIF   ('&KEYLEN' NE '').DCB
.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN
.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN
.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343
.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM
         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM
.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL
.TMSVGP  AIF   ('&MSVGP' NE '').MSVGP
.TTERM   AIF   ('&TERM' NE '').TERM
         AGO   .SVC99
.MCLAS   RCPMCLAS &MGMTCLAS                                *LBD-08MAY96
         AGO   .TSCLAS                                     *LBD-08MAY96
.SCLAS   RCPSCLAS &STORCLAS                                *LBD-08MAY96
         AGO   .TUNIT                                      *LBD-08MAY96
.TERM    RCPTERM
         AGO   .SVC99
.SSREQ   RCPSSREQ
         AGO   .TDSN
.DSN     RCPDSN &DSN&DA,&MEMBER
         AGO   .TDDN
.DSNPDE  RCPDSNPD &DSNPDE
         AGO   .TDDN
.DSNRT   RCPDSNRT &DSNRET
&DSNRTO  SETA  &DTUO-46
         AGO   .TDDN
.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X
               FORMS=&FORMS,FCB=&FCB,CHARS=&CHARS,OUTDES=&OUTDES
         AGO   .TDDN
.DUMMY   RCPDUMMY &DUMMY
         AGO   .TDDN
.QNAME   RCPQNAME &QNAME
         AGO   .TDDN
.DDN     RCPDDN &DDN&F&FILE
         AGO   .TMCLAS
.DDNRT   RCPDDNRT &DDNRET
&DDNRTO  SETA  &DTUO-10
         AGO   .TUNIT
.UNIT   RCPUNIT &UNIT,&VOL
         AIF   ('&UNITCNT' EQ '').TDEFER                   *LBD 06/86*
         RCPUNITC &UNITCNT                                 *LBD 06/86*
         AGO   .TDEFER                                     *LBD 03/86*
*        AGO   .TVOLRET
.DEFER   RCPDEFER                                          *LBD 03/86*
         AGO   .TVOLRET                                    *LBD 03/86*
.VOLRET  RCPVOLRT &VOLRET
&VOLRTO  SETA  &DTUO-8
         AGO   .TDSRGO
.DSORGRT RCPDSRGR
&DSRGRTO SETA  &DTUO-2
         AGO   .TLABEL
.LABEL   RCPLABEL &LABEL
         AGO   .TPSWD
.PASWORD RCPPSWD &PASWORD
         AGO   .TFORUSE
.FORUSER RCPFORUS &FORUSER
         AGO   .TTU
.TU      RCPTU &TU
         AGO   .TDISP
.DISP    RCPDISP &DISP
         AGO   .TSPACE
.SPACE   RCPSPACE &SPACE
         AGO   .TLRECL
.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X
               DSORG=&DSORG,KEYLEN=&KEYLEN
         AGO .TDCBDSN
.DCBDSN  RCPDCBDS &DCBDSN
         AGO .TDCBDDN
.DCBDDN  RCPDCBDD &DCBDDN
         AGO .TFREE                                              TE7343
.FREE    RCPFREE  &FREE                                          TE7343
         AGO   .TPERM
.PERM    RCPPERM
         AGO   .TSPECI
.MSVGP   RCPMSVGP &MSVGP
         AGO   .SVC99
.SPECIAL RCPSPEC &SPECIAL
.SVC99   ANOP
&DTUPO   SETA  &DTUPO-4
         SPACE
         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS
         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR
         RCPSR2 UNSAVE
&DTUPO   SETA  &DTUPO+4
         AIF   (NOT &DSECT).DYNA
         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY
         LA    R14,4(R1)               POINT TO REQUEST BLOCK
.DYNA    DYNALLOC
         AIF   (NOT &DSECT).LTR
         USING &DYNP.RB,R14            SET UP ADDRESSABILITY
**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **
.LTR     AIF   ('&ERROR' EQ '').TDDTO
         LTR   R15,R15                 TEST RETURN CODE
         BNZ   &ERROR                  BRANCH IF NON ZERO
.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE
&I       SETA  0
.DDNTOL  ANOP
&I       SETA  &I+1
         AIF   ('&DDNTO(&I)' EQ '').RESERVE
         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR
         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2
         AGO   .DDNTOL
.DDNTOR  ANOP
&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)
         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2
         AGO   .DDNTOL
.RESERVE AIF   (&DSECT).RESDS
         SPACE 1
***********************************************************************
**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **
***********************************************************************
         RCPDS
.SSP     ANOP
&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER
&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK
&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS
         AIF   (&DTUO EQ 0).DTU21
&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS
         AIF   (&DSNRTO EQ 0).TDDNRTO
&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN
.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11
&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME
.DTU11   AIF   (&VOLRTO EQ 0).DTU12
&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER
.DTU12   AIF   (&DSRGRTO EQ 0).DTU10
&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG
         AGO   .DTU10
.DTU21   ANOP
&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS
.DTU10   ANOP
&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED
         AIF   (&DSECT).DSP
         RCPDS
         SPACE 3
         AGO   .EXIT
.RESDS   ANOP
         AIF   ('&DYNSP' EQ '').SP3
         DYNSPACE ADD
.SP3     SPACE
&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA
         AGO   .SSP
.DSP     AIF   ('&MF(3)' EQ '').END1
&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA
.END1    ANOP
&SYSECT  CSECT
         SPACE 3
.EXIT    MEND
./ ADD NAME=CONCAT   0100-03065-03065-2223-00060-00060-00000-DYNALLC
         MACRO
         CONCAT &POSIT,&TYPE=,&EXIT=
         GBLA  &CONCATN,&CONCATX
         GBLB  &CONCATB,&CONCATD,&DDDFAIL,&DDDD
         AIF   (&DDDD).ERRDDDD
         AIF   ('&POSIT' EQ 'E').ENDCONC
         AIF   ('&POSIT' NE 'B').ERRPARM
         AIF   ('&TYPE&EXIT' EQ '').CONCB
         MNOTE 4,'TYPE AND EXIT IGNORED ON CONCAT B'
.CONCB   AIF   (&CONCATB).ERRB
&CONCATB SETB  1
&CONCATX SETA  4              INITIAL DISPLACEMENT INTO DDNAME LIST
*
         MNOTE *,'*   BEGIN CONCATENATION'
*
         MEXIT
.ENDCONC AIF   (NOT &CONCATB).ERRE
&CONCATB SETB  0
&CONCATD SETB  0
&CONCATX SETA  &CONCATX/10             INITIAL 4 WILL ROUND TO 0
         AIF   (&CONCATN GE &CONCATX).CONCT
&CONCATN SETA  &CONCATX
.CONCT   AIF   (&CONCATX LE 1).ERRNUMB
         MVC   ALOCONCA(4),=Y(X'01',&CONCATX) CODE, NUMBER OF DDNAMES
         LA    14,ALOCONCA             ADDRESS OF CONCATENATION TU
         AIF   ('&TYPE' EQ '' OR '&TYPE' EQ 'PERM').PERM
         AIF   ('&TYPE' NE 'TEMP').ERRTYPE
         ST    14,ALOBLOCK+20
         OI    ALOBLOCK+20,X'80'       SET END OF TU ADDR LIST
         AGO   .CONCA
.PERM    MVC   ALOBLOCK-8(4),=Y(X'04',0) PERMANENTLY CONCATENATED
         LA    15,ALOBLOCK-8
         STM   14,15,ALOBLOCK+20
         OI    ALOBLOCK+24,X'80'       SET END OF TU ADDR LIST
.CONCA   LA    0,X'0320'               DYNAMIC CONCATENATION
         AIF   ('&EXIT' EQ '').EXITDEF
         AIF   ('&EXIT'(1,1) EQ '(').LREXIT
         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
         AGO   .BALDDDD
.EXITDEF LA    15,ALODDERR             LOAD ERROR EXIT RTN ADDRESS
&DDDFAIL SETB  1                       IN-LINE EXIT NEEDED
         AGO   .BALDDDD
.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO
*
         MNOTE *,'*   END CONCATENTATION OF &CONCATX DDNAMES'
*
         MEXIT
.ERRDDDD MNOTE 12,'CONCAT MAY NOT BE ISSUED AFTER DDDD'
         MEXIT
.ERRB    MNOTE 12,'CONCAT E  MUST BE ISSUED BEFORE RE-ISSUING CONCAT B'
         MEXIT
.ERRE    MNOTE 12,'CONCAT E  MAY BE ISSUED ONLY AFTER CONCAT B'
         MEXIT
.ERRNUMB MNOTE 12,'AT LEAST 2 DD''S MUST BE CONCATENATED'
         MEXIT
.ERRTYPE MNOTE 8,'INVALID TYPE, &TYPE.. IGNORED'
         AGO   .PERM
.ERRPARM MNOTE 12,'INVALID POSITIONAL PARAMETER. SPECIFY B OR E'
         MEND
./ ADD NAME=DAPL     0100-03065-03065-2223-00022-00022-00000-DYNALLC
         MACRO
&X       DAPL  &Y,&DSECT=NO
***********************************************************************
*                                                                     *
*            DYNAMIC   ALLOCATION   PARAMETER   LIST                  *
*                                                                     *
***********************************************************************
         SPACE 1
         AIF   ('&DSECT' NE 'NO').DSECT
DAPL     DS    0A .                     DAIR PARM LIST
         AGO   .COM
.DSECT   ANOP
DAPL     DSECT ,                        DAIR PARM LIST
.COM     ANOP
DAPLUPT  DC    A(0) .                   USER PROF. TAB
DAPLECT  DC    A(0) .                   ENV. CTL TAB
DAPLECB  DC    A(0) .                   ECB
DAPLPSCB DC    A(0) .                   PROT STEP CB
DAPLDAPB DC    A(0) .                   DAIR PARM BLOCK
DAPLLEN  EQU   *-DAPL .                 LENGTH
         SPACE 2
         MEND
./ ADD NAME=DDD      0100-03065-03065-2223-00105-00105-00000-DYNALLC
         MACRO
&DDNAME  DDD   &DUMMY,&DSN=,&DSNAME=,&DISP=,&TERM=,&FREE=END,          *
               &UNIT=,&SPACE=,&MSVGP=,&VOL=,&VOLUME=,&LABEL=,&PROTECT=,*
               &DCB=,&SUBSYS=,                                         *
               &SYSOUT=,&DEST=,&HOLD=,&COPIES=,&OUTLIM=,&FCB=,&UCS=,   *
               &BURST=,&CHARS=,&FLASH=,&MODIFY=,                       *
               &KEYADDS=,&TYPE=PERM,&MOUNT=NO,&EXIT=ALODDERR
         GBLA  &X,&Y,&H,&N,&CONCATX,&R
         GBLB  &CONCATB,&CONCATD,&DDDFAIL,&DDDD
         LCLA  &A
         LCLC  &C,&D
         AIF   (&DDDD).ERRDDDD
&X       SETA  20 DISPLACEMENT FROM ALOBLOCK TO FIRST TEXT UNIT POINTER
&Y       SETA  20         NEGATIVE DISTANCE FROM ALOBLOCK TO FIRST DATA
&R       SETA  14                      FIRST REGISTER LOADED
         DDD5  &DDNAME,&DSN,&DSNAME,&DISP
         AIF   ('&TERM' EQ '').TERMX
         AIF   ('&TERM' NE 'TS').ERRTERM
         DDD0  =Y(X'28',0),,,,'TERM=TS'
.TERMX   AIF   ('&FREE' EQ 'END').FREEX
         AIF   ('&FREE' NE 'CLOSE').ERRFREE
         DDD0  =Y(X'1C',0),,,,'FREE=CLOSE'
.FREEX   AIF   ('&UNIT&SPACE&MSVGP' EQ '').DDD1X
         DDD1  &UNIT,&SPACE,&MSVGP
.DDD1X   AIF   ('&VOL&VOLUME&LABEL&PROTECT' EQ '').DDD2X
         AIF   ('&VOLUME' EQ '').DDD2V
         AIF   ('&VOL' NE '').ERRVOL
         DDD2  &VOLUME,&LABEL,&PROTECT
         AGO   .DDD2X
.DDD2V   DDD2  &VOL,&LABEL,&PROTECT
.DDD2X   AIF   ('&DUMMY&DCB&SUBSYS' EQ '').DDD3X
         DDD3  &DUMMY,&DCB,&SUBSYS
.DDD3X   AIF   ('&SYSOUT&DEST&HOLD&COPIES&OUTLIM&FCB&UCS' EQ '' AND    *
               '&BURST&CHARS&FLASH&MODIFY' EQ '').DDD4X
         DDD4  &SYSOUT,&DEST,&HOLD,&COPIES,&OUTLIM,&FCB,&UCS,          *
               &BURST,&CHARS,&FLASH,&MODIFY
.DDD4X   AIF   ('&KEYADDS' EQ '').KEYADDX
&A       SETA  0
.KEYLOOP AIF   (&A GE N'&KEYADDS).KEYADDX
&A       SETA  &A+1
&C       SETC  '&KEYADDS(&A)'
         AIF   ('&C' EQ '').KEYLOOP
         AIF   ('&C'(1,1) EQ '(').KEYADDR
         DDD0  &C,,,,'KEYADDS=&C'
         AGO   .KEYLOOP
.KEYADDR DDD0  0&C,,,,'KEYADDS=&C'
         AGO   .KEYLOOP
.KEYADDX AIF   ('&TYPE' EQ 'PERM').TYPEP
         AIF   ('&TYPE' EQ 'TEMP').TYPEX
         AIF   ('&TYPE' NE 'CNVRT').ERRTYPE
         DDD0  =Y(X'53',0),,,,'TYPE=CNVRT  CONVERTIBLE'
.TYPEP   DDD0  =Y(X'52',0),,,,'PERMANENTLY ALLOCATED'
.TYPEX   AIF   (&R NE 14).R14X
&X       SETA  &X-4
         AGO   .RX
.R14X    AIF   (&R NE 15).R15X
         ST    14,ALOBLOCK+&X
         AGO   .RX
.R15X    AIF   (&R NE 0).R0X
         STM   14,15,ALOBLOCK+&X
&X       SETA  &X+4
         AGO   .RX
.R0X     STM   14,0,ALOBLOCK+&X
&X       SETA  &X+8
.RX      OI    ALOBLOCK+&X,X'80'        SET END OF TEXT UNIT ADDR LIST
&C       SETC  'X''0100''+X''0020'''   ALLOC, NOMOUNT
         AIF   ('&MOUNT' EQ 'NO').MOUNTX
         AIF   ('&MOUNT' NE 'YES').ERRMOUN
&C       SETC  'X''0100'''             ALLOC
.MOUNTX  AIF   (NOT &CONCATD).CONCADX
&C       SETC  '&C+X''0080'''          DON'T USE EXISTING UNLESS CNVRT
.CONCADX LA    0,&C                    LOAD VERB, FLAGS1
         AIF   ('&EXIT'(1,1) EQ '(').LREXIT
         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
&DDDFAIL SETB  ('&EXIT' EQ 'ALODDERR' OR &DDDFAIL)
         AGO   .BALDDDD
.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO
         SPACE 1
         AIF   (NOT &CONCATB).CONCX
&CONCATD SETB  1
         MVC   ALOCONCA+&CONCATX.(10),ALORTDDN+4 SAVE DDNAME FOR CONCAT
&CONCATX SETA  &CONCATX+1
         MVI   ALOCONCA+&CONCATX,8     SET LENGTH TO 8 FOR SPACING
&CONCATX SETA  &CONCATX+9
         SPACE 1
.CONCX   AIF   (&H GE &Y).HX
&H       SETA  &Y
.HX      AIF   (&N GE &X).MEXIT
&N       SETA  &X
.MEXIT   MEXIT
.ERRDDDD MNOTE 12,'DDD MAY NOT BE ISSUED AFTER DDDD'
         MEXIT
.ERRFREE MNOTE 8,'FREE=&FREE INVALID. FREE=END ASSUMED.'
         AGO   .FREEX
.ERRVOL  MNOTE 12,'BOTH VOL= AND VOLUME= SPECIFIED. VOLUME=&VOLUME IGNO*
               RED.'
         AGO   .DDD2V
.ERRTERM MNOTE 8,'INVALID VALUE, TERM=&TERM.. IGNORED.'
         AGO   .TERMX
.ERRTYPE MNOTE 8,'TYPE=&TYPE INVALID. TYPE IGNORED.'
         AGO   .TYPEP
.ERRMOUN MNOTE 8,'MOUNT=&MOUNT INVALID. IGNORED.'
         AGO   .MOUNTX
         MEND
./ ADD NAME=DDDD     0100-03065-03065-2223-00069-00069-00000-DYNALLC
         MACRO
         DDDD  &ROLE
         GBLA  &H,&N,&CONCATN
         GBLB  &RTDDN,&FREEB,&DDDFAIL,&DDDD
&DDDD    SETB  1
         AIF   ('&ROLE' EQ 'STORAGE').CODEX
         DC    Y(X'8032'-X'10000')     CONTROL BITS FOR DAIRFAIL
ALOROUT  STCM  0,B'0011',ALOBLOCK+1    SET VERB AND FLAGS1
         AIF   ('&ROLE' EQ '').COMMON
         AIF   ('&ROLE' NE 'CODE').ERRROLE
         MVI   ALOBLOCK,20             SET BLOCK LENGTH = 20
         XC    ALOBLOCK+3(17),ALOBLOCK+3  PRESET BLOCK TO ZEROS
         LA    0,ALOBLOCK+20           POINTER TO TEXT UNIT ADDRESSES
         ST    0,ALOBLOCK+8            SET INTO BLOCK
         LA    0,ALOBLOCK              ADDRESS OF REQUEST BLOCK
         ST    0,ALOBLOCK-20           POINTER FOR SVC
         OI    ALOBLOCK-20,X'80'       SET END OF POINTER
.COMMON  LA    1,ALOBLOCK-20           POINT TO POINTER
         STM   14,1,12(13)             SAVE REGS IN CASE OF ERROR
         DYNALLOC ,                    DYNALLOC SVC
         LTR   15,15                   IF RETURN CODE IS ZERO,
         BZR   14                      RETURN TO MAINSTREAM
         ST    15,20(,13)              SAVE RETURN CODE IN REG 0 AREA
         LM    15,1,16(13)             LOAD EXIT ADDR, RC, AND POINTER
         ST    0,ALOBLOCK-4            RETURN CODE FOR DAIRFAIL
         BR    15                      GO TO EXIT RTN
         AIF   (NOT &DDDFAIL).EXITX
ALODDERR DS    0H
         AIF   (NOT &FREEB).FREEX
         CLC   ALOBLOCK+4(2),=X'0438'  "NOT FREED, IS NOT ALLOCATED"
         BER   14                      IS A PERMISSABLE ERROR
         CLC   ALOBLOCK+4(2),=X'0440'  "NOT FREED, IS NOT ALLOCATED"
         BER   14                      IS A PERMISSABLE ERROR
.FREEX   ANOP
ALODFAIL DS    0H
         L     15,16                   ADDRESS CVT
         AIF   ('&ROLE' EQ '').PARAMX
         LA    14,ALOBLOCK-4           RETURN CODE IN FULLWORD
         LA    15,976(,15)             CVTEFF02 POINTS TO IKJEFF02
         LA    0,ALOROUT-2             BITS TO CONTROL IKJEFF18
         STM   14,0,ALOBLOCK-20+4
         AGO   .STOREX
.PARAMX  LA    15,976(,15)             CVTEFF02 POINTS TO IKJEFF02
         ST    15,ALOBLOCK-20+8
.STOREX  LINK  EP=IKJEFF18,            INVOKE DAIRFAIL TO ISSUE WTP    *
               MF=(E,ALOBLOCK-20)
         L     1,=A(X'80000000'+99)    ABEND CODE IS USER 99,DUMP
         ABEND (1)                     ABEND
.EXITX   AIF   ('&ROLE' EQ 'CODE').MEXIT
.CODEX   ANOP
&H       SETA  &H/2-2
         DS    &H.H                    SPACE FOR SOME TEXT UNITS
         DC    A(*-X'7FFFFFEC')        ADDRESS OF ALOBLOCK
         DC    A(ALOBLOCK-4)           ADDRESS OF SVC RC FOR DAIRFAIL
         DC    A(0)                    ADDRESS OF FULLWORD -> IKJEFF02
         DC    A(ALOROUT-2)        ADDRESS OF CONTROL BITS FOR DAIRFAIL
         DS    F                   RETURN CODE FROM SVC 99 FOR DAIRFAIL
ALOBLOCK DC    X'14002000'             LENGTH, VERB, FLAGS1
         DC    A(0,*+12,0,0)   ERROR CODES, TU LIST ADDR, RESV, FLAGS2
&N       SETA  &N/4-4
         DS    &N.A                    TU ADDRESS LIST
         AIF   (NOT &RTDDN).ARTDDNX
ALORTDDN DC    Y(X'55',1,8),CL8' '     TU FOR RETURN OF DDNAME
DDDNAME  EQU   ALORTDDN+6,8,C'C'
.ARTDDNX AIF   (&CONCATN EQ 0).MEXIT
ALOCONCA DC    Y(1,0),&CONCATN.XL10'0' TU FOR DDNAMES TO CONCATENATE
.MEXIT   MEXIT
.ERRROLE MNOTE 12,'&ROLE IS INVALID. USE CODE OR STORAGE.'
         MEND
./ ADD NAME=DDDMSG   0100-03065-03065-2223-00006-00006-00000-DYNALLC
         MACRO
         DDDMSG
         LINK  EP=IKJEFF18,            INVOKE DAIRFAIL TO ISSUE WTP    *
               PARAM=(,ALOBLOCK-4,=F'0',ALOROUT-2),                    *
               MF=(E,ALOBLOCK-20)
         MEND
./ ADD NAME=DDDMVC   0100-03065-03065-2223-00007-00007-00000-DYNALLC
         MACRO
&NAME    DDDMVC &PARMS=,&RETURN=
         MVC   PARMLIST,ALOBLOCK-20
&NAME    LINK  EP=IKJEFF18,            INVOKE DAIRFAIL TO ISSUE WTP    *
               PARAM=(,ALOBLOCK-4,=F'0',=X'C032',=F'0',&RETURN),       *
               VL=1,MF=(E,&PARMS)
         MEND
./ ADD NAME=DDD0     0100-03065-03065-2223-00107-00107-00000-DYNALLC
***********************************************************************
*                                                                     *
*   MACRO DDD0                                                        *
*                                                                     *
*    FUNCTION: MOVE A SINGLE TEXT UNIT INTO THE TEXT UNIT AREA,       *
*      SET ITS ADDRESS INTO A REGISTER.  STORE ADDRESSES INTO THE     *
*      TEXT UNIT ADDRESS ARRAY.                                       *
*                                                                     *
*    OPERANDS: THERE ARE 5 POSITIONAL OPERANDS, P1 THRU P5.           *
*      OPERAND P5 IS ALWAYS A QUOTED STRING THAT DDD0 EXPANDS INTO A  *
*      COMMENT MNOTE. OPERANDS P1-P4 SPECIFY A TEXT UNIT IN ONE OF    *
*      SEVERAL WAYS:                                                  *
*        ADDRESS ONLY: P1 IS AN RX-TYPE ADDRESS OF A TEXT UNIT        *
*          PREFORMATTED BY THE INVOKER. DDD0 DOES NOT COPY THE TEXT   *
*          UNIT IN THIS CASE. THIS MODE IS SELECTED WHEN P2 IS        *
*          OMITTED.                                                   *
*        TWO-PART TEXT UNIT: P1 IS THE LENGTH (NON-RELOCATABLE        *
*          EXPRESSION WHOSE FIRST CHARACTER IS NUMERIC) AND P2 IS     *
*          THE ADDRESS (RS-TYPE) OF THE FIRST PART OF THE TEXT UNIT.  *
*          P3 IS THE LENGTH (NON-RELOCATABLE EXPRESSION) AND P4 IS    *
*          THE ADDRESS (RS-TYPE) OF THE SECOND PART OF THE TEXT       *
*          UNIT. DDD0 COPIES BOTH PARTS TO THE TEXT UNIT AREA. THIS   *
*          MODE IS SELECTED WHEN P2 IS NOT OMITTED, THE FIRST         *
*          CHARACTER OF P1 IS NUMERIC AND P3 IS NOT OMITTED.          *
*        ONE-PART TEXT UNIT: P1 IS THE LENGTH (NON-RELOCATABLE        *
*          EXPRESSION WHOSE FIRST CHARACTER IS NUMERIC) AND P2 IS     *
*          THE ADDRESS (RS-TYPE) OF THE TEXT UNIT.  DDD0 COPIES THE   *
*          TEXT UNIT TO THE TEXT UNIT AREA. THIS MODE IS SELECTED     *
*          WHEN P2 IS NOT OMITTED, THE FIRST CHARACTER OF P1 IS       *
*          NUMERIC AND P3 IS OMITTED.                                 *
*        CHARACTER-STRING VALUE: P1 (A-TYPE ADDRESS CONSTANT WHOSE    *
*          FIRST CHARACTER IS NOT NUMERIC) IS THE KEY AND NUMBER OF   *
*          PARAMETERS (MUST BE 1) OF THE TEXT UNIT.  P2 IS AN         *
*          UNQUOTED STRING USED BY DDD0 AS THE VALUE OF THE FIRST     *
*          PARAMETER. DDD0 WILL EFFECTIVELY REMOVE THE FIRST          *
*          CHARACTER OF THE STRING IF THE FIRST TWO CHARACTERS ARE    *
*          BOTH AMPERSANDS. DDD0 SETS THE LENGTH OF THE FIRST         *
*          PARAMETER TO THE LENGTH OF THE P2 STRING (AFTER AMPERSAND  *
*          REMOVAL, IF ANY). P3 IS AN UPPER LIMIT TO THE LENGTH OF    *
*          P2 (BEFORE AMPERSAND REMOVAL). DDD0 COPIES THE TEXT UNIT   *
*          TO THE TEXT UNIT AREA. THIS MODE IS SELECTED WHEN P2 IS    *
*          NOT OMITTED AND P1'S FIRST CHARACTER IS NOT NUMERIC.       *
*                                                                     *
***********************************************************************
         MACRO
         DDD0  &ID,&CH,&L2,&A2,&COMMENT
         GBLA  &X,&Y,&R
         LCLA  &A,&K
         LCLC  &C
         SPACE 1
         MNOTE *,&COMMENT
         AIF   (T'&CH NE 'O').KEYADDX
         AIF   ('&ID'(K'&ID,1) NE '@').PSREGX
&C       SETC  '&ID'(1,K'&ID-1)
         L     &R,&C
         AGO   .CODEX
.PSREGX  LA    &R,&ID
         AGO   .CODEX
.KEYADDX ANOP
.*
         AIF   ('&ID'(1,1) LT '0').MOVLITX
         AIF   (T'&L2 EQ 'O').MOVVALX
&Y       SETA  (&Y+&L2+1)/2*2
         MVC   ALOBLOCK-&Y.(&L2),&A2
.MOVVALX ANOP
&Y       SETA  (&Y+&ID+1)/2*2
         MVC   ALOBLOCK-&Y.(&ID),&CH
         LA    &R,ALOBLOCK-&Y
         AGO   .CODEX
.MOVLITX ANOP
.*
&K       SETA  K'&CH
         AIF   (&K GT &L2).ERRLEN
&C       SETC  '&CH '(1,2)
&A       SETA  3
         AIF   ('&C' NE '&&').LOOP
&A       SETA  4
&C       SETC  '&CH '(1,3)
.LOOP    AIF   (&A GT &K).SETK
&C       SETC  '&C'',C'''.'&CH   '(&A,4)
&A       SETA  &A+4
         AGO   .LOOP
.SETK    AIF   ('&CH '(1,2) NE '&&').LA
&K       SETA  &K-1
.LA      ANOP
&A       SETA  &K+6
&Y       SETA  (&Y+&A+1)/2*2
         MVC   ALOBLOCK-&Y.(&A),=A(&ID,&K*X'10000'+C'&C')
         LA    &R,ALOBLOCK-&Y
.CODEX   ANOP
.*
         AIF   (&R NE 14).R14X
&R       SETA  15
         MEXIT
.R14X    AIF   (&R NE 15).R15X
&R       SETA  0
         MEXIT
.R15X    AIF   (&R NE 0).R0X
&R       SETA  1
         MEXIT
.R0X     STM   14,1,ALOBLOCK+&X
&X       SETA  &X+16
&R       SETA  14
         MEXIT
.ERRLEN  MNOTE 12,'OPERAND ''&CH'' EXCEEDS &L2 CHARACTERS. OPERAND IGNO*
               RED.'
         MEND
./ ADD NAME=DDD1     0100-03065-03065-2223-00156-00156-00000-DYNALLC
         MACRO
         DDD1  &UNIT,&SPACE,&MSVGP
         LCLA  &A,&K
         LCLB  &B,&T
         LCLC  &C,&D
         AIF   ('&UNIT' EQ '').UNITX
         AIF   (N'&UNIT GT 3).ERRUNI9
&C       SETC  '&UNIT(1)'
         AIF   ('&C' EQ '').UNIT1X
         AIF   ('&C'(K'&C,1) NE '@').UNIT1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'15',1,8),8,&C,'UNIT=CL8 AT &C'
         AGO   .UNIT1X
.UNIT1@X DDD0  X'00150001',&C,8,,'UNIT=&C'
.UNIT1X  AIF   (N'&UNIT LE 1).UNITX
&C       SETC  '&UNIT(2)'
         AIF   ('&C' EQ '').UNIT2X
         AIF   ('&C' NE 'P').UNITC
         DDD0  =Y(X'17',0),,,,'UNIT=(,P)  PARALLEL MOUNT'
         AGO   .UNIT2X
.UNITC   AIF   ('&C'(K'&C,1) NE '@').UNITC@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'16',1,1),1,&C,'UNIT=(,AL1 AT &C)  UNIT COUNT'
         AGO   .UNIT2X
.UNITC@X DDD0  7,=AL1(0,X'16',0,1,0,1,&C),,,'UNIT=(,&C)  UNIT COUNT'
.UNIT2X  AIF   ('&UNIT(3)' EQ '').UNITX
         AIF   ('&UNIT(3)' NE 'DEFER').ERRUNIT
         DDD0  =Y(X'6C',0),,,,'UNIT=(,,DEFER)  DEFERRED MOUNTING'
.UNITX   AIF   ('&SPACE' EQ '').SPACEX
         AIF   (N'&SPACE GT 5).ERRSPA9
&C       SETC  '&SPACE(1)'
         AIF   ('&C' EQ '').SPACE1X
         AIF   ('&C' NE 'TRK').SPACE1C
         DDD0  =Y(X'07',0),,,,'SPACE=(TRK)'
         AGO   .SPACE1X
.SPACE1C AIF   ('&C' NE 'CYL').SPACE1A
         DDD0  =Y(X'08',0),,,,'SPACE=(CYL)'
         AGO   .SPACE1X
.SPACE1A AIF   ('&C'(K'&C,1) NE '@').SPAC1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'09',1,3),3,&C,                                   *
               'SPACE=(AL3 AT &C)  AVERAGE BLOCK SIZE'
         AGO   .SPACE1X
.SPAC1@X DDD0  9,=AL3(X'000900',X'010003',&C),,,                       *
               'SPACE=(&C)  AVERAGE BLOCK SIZE'
.SPACE1X AIF   ('&SPACE(2)' EQ '').SPACE2X
&C       SETC  '&SPACE(2)'
         AIF   ('&C'(1,1) NE '(').SPACE2W
&A       SETA  2
.SPACE2A AIF   ('&C'(&A,1) EQ ',' AND &K EQ 0).SPACE2C
&B       SETB  ('&C'(&A,1) EQ '(')
&T       SETB  ('&C'(&A,1) EQ ')')
&K       SETA  &K+&B-&T
&A       SETA  &A+1
         AIF   (&A LT K'&C).SPACE2A
.SPACE2C AIF   (&A EQ 2).SPAC21X
&D       SETC  '&C'(2,&A-2)
         AIF   ('&D'(K'&D,1) NE '@').SPA21@X
&D       SETC  '&D'(1,K'&D-1)
         DDD0  6,=Y(X'0A',1,3),3,&D,'SPACE=(,(AL3 AT &D))'
         AGO   .SPAC21X
.SPA21@X DDD0  9,=AL3(X'000A00',X'010003',&D),,,'SPACE=(,(&D))'
.SPAC21X AIF   (&A GE K'&C).SPACE2X
&C       SETC  '&C'(&A+1,K'&C-&A)
&A       SETA  1
.SPACE2D AIF   ('&C'(&A,1) EQ ',' AND &K EQ 0).SPACE2E
&B       SETB  ('&C'(&A,1) EQ '(')
&T       SETB  ('&C'(&A,1) EQ ')')
&K       SETA  &K+&B-&T
&A       SETA  &A+1
         AIF   (&A LT K'&C).SPACE2D
.SPACE2E AIF   (&A EQ 1).SPAC22X
&D       SETC  '&C'(1,&A-1)
         AIF   ('&D'(K'&D,1) NE '@').SPA22@X
&D       SETC  '&D'(1,K'&D-1)
         DDD0  6,=Y(X'0B',1,3),3,&D,'SPACE=(,(,AL3 AT &D))'
         AGO   .SPAC22X
.SPA22@X DDD0  9,=AL3(X'000B00',X'010003',&D),,,'SPACE=(,(,&D))'
.SPAC22X AIF   (&A GE K'&C).SPACE2X
&C       SETC  '&C'(&A+1,K'&C-&A)
&A       SETA  1
.SPACE2G AIF   ('&C'(&A,1) EQ ',' AND &K EQ 0).ERRSPA2
&B       SETB  ('&C'(&A,1) EQ '(')
&T       SETB  ('&C'(&A,1) EQ ')')
&K       SETA  &K+&B-&T
&A       SETA  &A+1
         AIF   (&A LT K'&C).SPACE2G
&D       SETC  '&C'(1,&A-1)
         AIF   ('&D'(K'&D,1) NE '@').SPA23@X
&D       SETC  '&D'(1,K'&D-1)
         DDD0  6,=Y(X'0C',1,3),3,&D,'SPACE=(,(,,AL3 AT &D))'
         AGO   .SPACE2X
.SPA23@X DDD0  9,=AL3(X'000C00',X'010003',&D),,,'SPACE=(,(,,&D))'
         AGO   .SPACE2X
.SPACE2W AIF   ('&C'(K'&C,1) NE '@').SPAC2@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'0A',1,3),3,&C,'SPACE=(,AL3 AT &C)'
         AGO   .SPACE2X
.SPAC2@X DDD0  9,=AL3(X'000A00',X'010003',&C),,,'SPACE=(,&C)'
.SPACE2X AIF   (N'&SPACE LE 3).SPACE3
         AIF   ('&SPACE(5)' EQ '').SPACE4
         AIF   ('&SPACE(5)' NE 'ROUND').ERRSPA5
         DDD0  =Y(X'0F',0),,,,'SPACE=(,,,,ROUND)'
.SPACE4  ANOP
&C       SETC  '&SPACE(4)'
         AIF   ('&C' EQ '').SPACE3
         AIF   ('&C' NE 'CONTIG').SPACE4A
         DDD0  7,=AL1(0,X'0E',0,1,0,1,X'08'),,,'SPACE=(,,,CONTIG)'
         AGO   .SPACE3
.SPACE4A AIF   ('&C' NE 'ALX').SPACE4M
         DDD0  7,=AL1(0,X'0E',0,1,0,1,X'02'),,,'SPACE=(,,,ALX)'
         AGO   .SPACE3
.SPACE4M AIF   ('&C' NE 'MXIG').SPACE4@
         DDD0  7,=AL1(0,X'0E',0,1,0,1,X'04'),,,'SPACE=(,,,MXIG)'
         AGO   .SPACE3
.SPACE4@ AIF   ('&C'(K'&C,1) NE '@').ERRSPA4
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'0E',1,1),1,&C,'SPACE=(,,,XL1 AT &C)'
.SPACE3  AIF   ('&SPACE(3)' EQ '').SPACEX
         AIF   ('&SPACE(3)' NE 'RLSE').ERRRLSE
         DDD0  =Y(X'0D',0),,,,'SPACE=(,,RLSE)'
.SPACEX  AIF   ('&MSVGP' EQ '').MSVGPX
         AIF   (N'&MSVGP GT 2).ERRMSV9
         AIF   (N'&MSVGP LE 1).MSVDDX
         MNOTE 8,'SECOND SUBPARAMETER OF MSVGP NOT SUPPORTED BY DYNAMIC*
                ALLOCATION.'
.MSVDDX  ANOP
&C       SETC  '&MSVGP(1)'
         AIF   ('&C' EQ '').MSVGPX
         AIF   ('&C'(K'&C,1) NE '@').MSVGP@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'5E',1,8),8,&C,'MSVGP=CL8 AT &C'
         AGO   .MSVGPX
.MSVGP@X DDD0  X'005E0001',&C,8,,'MSVGP=&C'
.MSVGPX  MEXIT
.ERRUNI9 MNOTE 8,'ONLY THREE SUBPARAMETERS ALLOWED IN UNIT=&UNIT.. UNIT*
                IGNORED.'
         AGO   .UNITX
.ERRUNIT MNOTE 8,'UNIT=(,,&UNIT(3)) IS INVALID. IGNORED.'
         AGO   .UNITX
.ERRSPA9 MNOTE 8,'ONLY FIVE SUBPARAMETERS ALLOWED IN SPACE=&SPACE.. SPA*
               CE IGNORED.'
         AGO   .SPACEX
.ERRSPA2 MNOTE 8,'TOO MAY SUBPARAMETERS IN SECOND SPACE PARAMETER, &SPA*
               CE(2)'
         AGO   .SPACE2X
.ERRRLSE MNOTE 8,'INVALID THIRD SPACE PARAMETER, &SPACE(3)'
         AGO   .SPACEX
.ERRSPA4 MNOTE 8,'INVALID FOURTH SPACE PARAMETER, &C'
         AGO   .SPACE3
.ERRSPA5 MNOTE 8,'INVALID FIFTH SPACE PARAMETER, &SPACE(5)'
         AGO   .SPACE4
.ERRMSV9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN MSVGP=&MSVGP.. MSVG*
               P IGNORED.'
         AGO   .MSVGPX
         MEND
./ ADD NAME=DDD2     0100-03065-03065-2223-00198-00198-00000-DYNALLC
         MACRO
         DDD2  &VOL,&LABEL,&PROTECT
         LCLA  &A
         LCLC  &C,&D
         AIF   ('&VOL' EQ '').VOLX
&C       SETC  '&VOL(N'&VOL)'
         AIF   ('&C'(1,4) NE 'SER=').VOLREF
         AIF   ('&C'(5,1) EQ '(').VOLMULT
         AIF   ('&C'(K'&C,1) NE '@').VOLS1@X
&C       SETC  '&C'(5,K'&C-5)
         DDD0  6,=Y(X'10',1,6),6,&C,'VOL=SER=CL6 AT &C'
         AGO   .VOLKEYX
.VOLS1@X AIF   (K'&C NE 10).ERRVOS1
&C       SETC  '&C'(5,6)
         DDD0  X'00100001',&C,6,,'VOL=SER=&C'
         AGO   .VOLKEYX
.VOLMULT AIF   ('&C'(K'&C-1,1) NE '@').VOLMU@X
&C       SETC  '&C'(6,K'&C-7)
         DDD0  6,=Y(X'10',1,6),6,&C,'VOL=SER=CL6 AT &C'
         AGO   .VOLKEYX
.VOLMU@X ANOP
&D       SETC  'X''00060000''+C'''.'&C'(6,2).''',C'''.'&C'(8,4).''''
&A       SETA  12
.VOLLOOP AIF   ('&C'(&A,1) NE ',').ERRVOLS
&D       SETC  '&D,X''00060000''+C'''.'&C'(&A+1,2).''',C'''.'&C'(&A+3,4*
               ).''''
&A       SETA  &A+7
         AIF   (&A LT K'&C).VOLLOOP
&A       SETA  &A/7
&D       SETC  'X''00100000''+&A,&D'
&A       SETA  &A*8+4
         DDD0  &A,=A(&D),,,'VOL=&C'
         AGO   .VOLKEYX
.VOLREF  AIF   ('&C'(1,4) NE 'REF=').VOL4
         AIF   ('&C'(5,1) EQ '*').ERRVOLR
         AIF   ('&C'(K'&C,1) NE '@').VOLRE@X
&C       SETC  '&C'(5,K'&C-5)
         DDD0  6,=Y(X'14',1,44),44,&C,'VOL=REF=CL44 AT &C'
         AGO   .VOLKEYX
.VOLRE@X ANOP
&C       SETC  '&C'(5,K'&C-4)
         DDD0  X'00140001',&C,44,,'VOL=REF=&C'
.VOLKEYX AIF   (N'&VOL LE 1).VOLX
         AIF   (N'&VOL LE 2).VOL2X
         AIF   (N'&VOL LE 3).VOL3X
         AIF   (N'&VOL LE 4).VOL4X
         AIF   (N'&VOL LE 5).VOL5X
.VOL4    AIF   (N'&VOL GT 4).ERRVOL9
.VOL5X   ANOP
&C       SETC  '&VOL(4)'
         AIF   ('&C' EQ '').VOL4X
         AIF   ('&C'(K'&C,1) NE '@').VOL4@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'13',1,1),1,&C,'VOL=(,,,AL1 AT &C)  VOLUME COUNT'
         AGO   .VOL4X
.VOL4@X  DDD0  7,=AL1(0,X'13',0,1,0,1,&C),,,'VOL=(,,,&C)  VOLUME COUNT'
.VOL4X   ANOP
&C       SETC  '&VOL(3)'
         AIF   ('&C' EQ '').VOL3X
         AIF   ('&C'(K'&C,1) NE '@').VOL3@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'12',1,2),2,&C,'VOL=(,,AL2 AT &C)  VOLUME SEQUENCE*
                NUMBER'
         AGO   .VOL3X
.VOL3@X  DDD0  8,=Y(X'12',1,2,&C),,,'VOL=(,,&C)  VOLUME SEQUENCE NUMBER*
               '
.VOL3X   AIF   ('&VOL(2)' EQ '').VOL2X
         AIF   ('&VOL(2)' NE 'RETAIN').ERRVOL2
         MNOTE 8,'VOL=(,RETAIN) NOT SUPPORTED BY DYNAMIC ALLOCATION'
.VOL2X   AIF   ('&VOL(1)' EQ '').VOLX
         AIF   ('&VOL(1)' NE 'PRIVATE').ERRVOL1
         DDD0  =Y(X'11',0),,,,'VOL=(PRIVATE)'
.VOLX    AIF   ('&LABEL' EQ '').LABELX
&C       SETC  '&LABEL(N'&LABEL)'
         AIF   ('&C'(1,6) NE 'EXPDT=').LABELEX
         AIF   ('&C'(K'&C,1) NE '@').LABE@X
&C       SETC  '&C'(7,K'&C-7)
         DDD0  6,=Y(X'22',1,5),5,&C,'LABEL=EXPDT=CL5 AT &C'
         AGO   .LABKEYX
.LABE@X  AIF   (K'&C NE 11).ERREXPD
&C       SETC  '&C'(7,5)
         DDD0  X'00220001',&C,5,,'LABEL=EXPDT=&C'
         AGO   .LABKEYX
.LABELEX AIF   ('&C'(1,6) NE 'RETPD=').LABELRX
         AIF   ('&C'(K'&C,1) NE '@').LABR@X
&C       SETC  '&C'(7,K'&C-7)
         DDD0  6,=Y(X'23',1,2),2,&C,'LABEL=RETPD=AL2 AT &C'
         AGO   .LABKEYX
.LABR@X  ANOP
&C       SETC  '&C'(7,K'&C-6)
         DDD0  8,=Y(X'23',1,2,&C),,,'LABEL=RETPD=&C'
.LABKEYX AIF   (N'&LABEL LE 1).LABELX
         AIF   (N'&LABEL LE 2).LABEL2X
         AIF   (N'&LABEL LE 3).LABEL3X
         AIF   (N'&LABEL LE 4).LABEL4X
         AIF   (N'&LABEL LE 5).LABEL5X
.LABELRX AIF   (N'&LABEL GT 4).ERRLAB9
.LABEL5X ANOP
&C       SETC  '&LABEL(4)'
         AIF   ('&C' EQ '').LABEL4X
         AIF   ('&C' NE 'IN').LABEL4A
         DDD0  7,=AL1(0,X'21',0,1,0,1,X'80'),,,'LABEL=(,,,IN)'
         AGO   .LABEL4X
.LABEL4A AIF   ('&C' NE 'OUT').LABEL4@
         DDD0  7,=AL1(0,X'21',0,1,0,1,X'40'),,,'LABEL=(,,,OUT)'
         AGO   .LABEL4X
.LABEL4@ AIF   ('&C'(K'&C,1) NE '@').ERRLAB4
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'21',1,1),1,&C,'LABEL=(,,,XL1 AT &C)  INPUT ONLY O*
               R OUTPUT ONLY'
.LABEL4X ANOP
&C       SETC  '&LABEL(3)'
         AIF   ('&C' EQ '').LABEL3X
         AIF   ('&C' NE 'PASSWORD').LABEL3A
         DDD0  7,=AL1(0,X'20',0,1,0,1,X'10'),,,'LABEL=(,,PASSWORD)'
         AGO   .LABEL3X
.LABEL3A AIF   ('&C' NE 'NOPWREAD').LABEL3@
         DDD0  7,=AL1(0,X'20',0,1,0,1,X'30'),,,'LABEL=(,,NOPWREAD)'
         AGO   .LABEL3X
.LABEL3@ AIF   ('&C'(K'&C,1) NE '@').ERRLAB3
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'20',1,1),1,&C,'LABEL=(,,XL1 AT &C)  PASSWORD PROT*
               ECTION'
.LABEL3X ANOP
&C       SETC  '&LABEL(2)'
         AIF   ('&C' EQ '').LABEL2X
         AIF   ('&C' NE 'NSL').LABEL2A
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'04'),,,'LABEL=(,NSL)'
         AGO   .LABEL2X
.LABEL2A AIF   ('&C' NE 'SL').LABEL2B
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'02'),,,'LABEL=(,SL)'
         AGO   .LABEL2X
.LABEL2B AIF   ('&C' NE 'NL').LABEL2C
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'01'),,,'LABEL=(,NL)'
         AGO   .LABEL2X
.LABEL2C AIF   ('&C' NE 'BLP').LABEL2D
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'10'),,,'LABEL=(,BLP)'
         AGO   .LABEL2X
.LABEL2D AIF   ('&C' NE 'SUL').LABEL2E
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'08'),,,'LABEL=(,SUL)'
         AGO   .LABEL2X
.LABEL2E AIF   ('&C' NE 'AL').LABEL2F
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'40'),,,'LABEL=(,AL)'
         AGO   .LABEL2X
.LABEL2F AIF   ('&C' NE 'AUL').LABEL2G
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'48'),,,'LABEL=(,AUL)'
         AGO   .LABEL2X
.LABEL2G AIF   ('&C' NE 'LTM').LABEL2@
         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'21'),,,'LABEL=(,LTM)'
         AGO   .LABEL2X
.LABEL2@ AIF   ('&C'(K'&C,1) NE '@').ERRLAB2
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'1E',1,1),1,&C,'LABEL=(,XL1 AT &C)  LABEL TYPE'
.LABEL2X ANOP
&C       SETC  '&LABEL(1)'
         AIF   ('&C' EQ '').LABELX
         AIF   ('&C'(K'&C,1) NE '@').LABE1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'1F',1,2),2,&C,'LABEL=(AL2 AT &C)  DATASET SEQUENC*
               E NUMBER'
         AGO   .LABELX
.LABE1@X DDD0  8,=Y(X'1F',1,2,&C),,,'LABEL=(&C)  DATASET SEQUENCE NUMBE*
               R'
.LABELX  AIF   ('&PROTECT' EQ '').PROTECX
         AIF   ('&PROTECT' NE 'YES').ERRPROT
         DDD0  =Y(X'61',0),,,,'PROTECT=YES'
.PROTECX MEXIT
.ERRVOL9 MNOTE 8,'ONLY FOUR POSITIONAL SUBPARAMETERS ALLOWED IN VOL=&VO*
               L.. POSITIONAL SUBPARAMETERS OF VOL IGNORED'
         AGO   .VOLX
.ERRVOS1 ANOP
&A       SETA  12
.ERRVOLS ANOP
&A       SETA  &A/7
         MNOTE 8,'VOLUME &A IN VOL=&C DOES NOT HAVE 6 CHARACTERS. VOL=S*
               ER IGNORED.'
         AGO   .VOLKEYX
.ERRVOLR MNOTE 8,'VOLUME REFERENCE BY DDNAME IN VOL=&C NOT SUPPORTED BY*
                DYNAMIC ALLOCATION. IGNORED.'
         AGO   .VOLKEYX
.ERRVOL2 MNOTE 8,'VOL=(,&VOL(2)) INVALID. IGNORED.'
         AGO   .VOL2X
.ERRVOL1 MNOTE 8,'VOL=(&VOL(1)) INVALID. IGNORED.'
         AGO   .VOLX
.ERRLAB9 MNOTE 8,'ONLY FOUR POSITIONAL SUBPARAMETERS ALLOWED IN LABEL=&*
               LABEL.. POSITIONAL SUBPARAMETERS OF LABEL IGNORED'
         AGO   .LABELX
.ERREXPD MNOTE 8,'LABEL=&C INVALID. IGNORED.'
         AGO   .LABKEYX
.ERRLAB2 MNOTE 8,'LABEL=(,&C) INVALID. IGNORED.'
         AGO   .LABEL2X
.ERRLAB3 MNOTE 8,'LABEL=(,,&LABEL(3)) INVALID. IGNORED.'
         AGO   .LABEL3X
.ERRLAB4 MNOTE 8,'LABEL=(,,,&C) INVALID. IGNORED.'
         AGO   .LABEL4X
.ERRPROT MNOTE 8,'PROTECT=&PROTECT INVALID. PROTECT IGNORED'
         AGO   .PROTECX
         MEND
./ ADD NAME=DDD3     0100-03065-03065-2223-00296-00296-00000-DYNALLC
         MACRO
         DDD3  &DUMMY,&DCB,&SUBSYS
         GBLA  &Y
         LCLA  &A,&K,&L,&M1,&M2
         LCLB  &@,&B0,&B1,&B2,&B3,&B4,&B5,&B6
         LCLB  &O0,&O1,&O2,&O3,&O4,&O5,&O6,&O7
         LCLC  &C,&D
         AIF   ('&DUMMY' EQ '').DUMMYX
         AIF   ('&DUMMY' NE 'DUMMY').ERRDUMM
         DDD0  =Y(X'24',0),,,,'DUMMY'
.DUMMYX  AIF   ('&DCB' EQ '').DCBX
&A       SETA  N'&DCB+1
.DCBLOOP AIF   (&A LE 1).DCBX
&A       SETA  &A-1
&C       SETC  '&DCB(&A)'
&@       SETB  0
         AIF   ('&C'(K'&C,1) NE '@').@X
&@       SETB  1
&C       SETC  '&C'(1,K'&C-1)
.@X      AIF   (K'&C LE 5).DCB4
         AIF   ('&C'(1,8) NE 'BLKSIZE=').BLKSIZX
&C       SETC  '&C'(9,K'&C-8)
         AIF   (&@).BLKSIZ@
         DDD0  8,=Y(X'30',1,2,&C),,,'DCB=BLKSIZE=&C'
         AGO   .DCBLOOP
.BLKSIZ@ DDD0  6,=Y(X'30',1,2),2,&C,'DCB=BLKSIZE=AL2 AT &C'
         AGO   .DCBLOOP
.BLKSIZX AIF   ('&C'(6,1) NE '=').DCB7
&D       SETC  '&C'(1,5)
&C       SETC  '&C'(7,K'&C-6)
         AIF   ('&D' NE 'BUFNO').BUFNOX
         AIF   (&@).BUFNO@
         DDD0  7,=AL1(0,X'34',0,1,0,1,&C),,,'DCB=BUFNO=&C'
         AGO   .DCBLOOP
.BUFNO@  DDD0  6,=Y(X'34',1,1),1,&C,'DCB=BUFNO=AL1 AT &C'
         AGO   .DCBLOOP
.BUFNOX  AIF   ('&D' NE 'RECFM').RECFMX
         AIF   (&@).RECFM@
&K       SETA  K'&C+1
.RECFMA  AIF   (&K LE 1).RECFMW
&K       SETA  &K-1
&D       SETC  '&C'(&K,1)
         AIF   ('&D' NE 'F' AND '&D' NE 'U' AND '&D' NE 'V').RECFMB
&B0      SETB  ('&D' EQ 'F' OR '&D' EQ 'U')
&B1      SETB  ('&D' EQ 'V' OR '&D' EQ 'U')
         AGO   .RECFMA
.RECFMB  AIF   ('&D' NE 'B').RECFMC
&B3      SETB  1
         AGO   .RECFMA
.RECFMC  AIF   ('&D' NE 'S').RECFMD
&B4      SETB  1
         AGO   .RECFMA
.RECFMD  AIF   ('&D' NE 'A').RECFME
&B5      SETB  1
         AGO   .RECFMA
.RECFME  AIF   ('&D' NE 'M').RECFMF
&B6      SETB  1
         AGO   .RECFMA
.RECFMF  AIF   ('&D' NE 'T').RECFMG
&B2      SETB  1
         AGO   .RECFMA
.RECFMG  AIF   ('&D' NE 'D').RECFMH
&B2      SETB  1
         AGO   .RECFMA
.RECFMH  AIF   ('&D' NE 'G').RECFMI
&B5      SETB  1
         AGO   .RECFMA
.RECFMI  AIF   ('&D' NE 'R').ERRRECF
&B6      SETB  1
         AGO   .RECFMA
.RECFMW  DDD0  7,=AL1(0,X'49',0,1,0,1,B'&B0&B1&B2&B3&B4&B5&B6.0'),,,   *
               'DCB=RECFM=&C'
         AGO   .DCBLOOP
.RECFM@  DDD0  6,=Y(X'49',1,1),1,&C,'DCB=RECFM=XL1 AT &C'
         AGO   .DCBLOOP
.RECFMX  AIF   ('&D' NE 'OPTCD').OPTCDX
         AIF   (&@).OPTCD@
&K       SETA  K'&C+1
.OPTCDA  AIF   (&K LE 1).OPTCDW
&K       SETA  &K-1
&D       SETC  '&C'(&K,1)
         AIF   ('&D' NE 'W').OPTCDWX
&O0      SETB  1
         AGO   .OPTCDA
.OPTCDWX AIF   ('&D' NE 'B' AND '&D' NE 'U').OPTCBUX
&O1      SETB  1
         AGO   .OPTCDA
.OPTCBUX AIF   ('&D' NE 'C' AND '&D' NE 'E').OPTCCEX
&O2      SETB  1
         AGO   .OPTCDA
.OPTCCEX AIF   ('&D' NE 'F' AND '&D' NE 'H' AND '&D' NE 'O').OPTFHOX
&O3      SETB  1
         AGO   .OPTCDA
.OPTFHOX AIF   ('&D' NE 'A' AND '&D' NE 'Q').OPTCAQX
&O4      SETB  1
         AGO   .OPTCDA
.OPTCAQX AIF   ('&D' NE 'Z').OPTCDZX
&O5      SETB  1
         AGO   .OPTCDA
.OPTCDZX AIF   ('&D' NE 'T').OPTCDTX
&O6      SETB  1
         AGO   .OPTCDA
.OPTCDTX AIF   ('&D' NE 'R' AND '&D' NE 'J').ERROPTC
&O7      SETB  1
         AGO   .OPTCDA
.OPTCDW  DDD0  7,=AL1(0,X'45',0,1,0,1,B'&O0&O1&O2&O3&O4&O5&O6&O7'),,,  *
               'DCB=OPTCD=&C'
         AGO   .DCBLOOP
.OPTCD@  DDD0  6,=Y(X'45',1,1),1,&C,'DCB=OPTCD=XL1 AT &C'
         AGO   .DCBLOOP
.OPTCDX  AIF   ('&D' NE 'LRECL').LRECLX
         AIF   (&@).LRECL@
         AIF   ('&C' EQ 'X').LRECLA
         DDD0  8,=Y(X'42',1,2,&C),,,'DCB=LRECL=&C'
         AGO   .DCBLOOP
.LRECL@  DDD0  6,=Y(X'42',1,2),2,&C,'DCB=LRECL=AL2 AT &C'
         AGO   .DCBLOOP
.LRECLA  DDD0  8,=Y(X'42',1,2,-X'8000'),'DCB=LRECL=X  VBS ONLY'
         AGO   .DCBLOOP
.LRECLX  AIF   ('&D' NE 'DSORG').DSORGX
         AIF   (&@).DSORG@
         AIF   ('&C' NE 'PO').DSORGS
         DDD0  8,=Y(X'3C',1,2,X'0200'),,,'DCB=DSORG=PO'
         AGO   .DCBLOOP
.DSORGS  AIF   ('&C' NE 'PS').DSORGD
         DDD0  8,=Y(X'3C',1,2,X'4000'),,,'DCB=DSORG=PS'
         AGO   .DCBLOOP
.DSORGD  AIF   ('&C' NE 'DA').ERRDSOR
         DDD0  8,=Y(X'3C',1,2,X'2000'),,,'DCB=DSORG=DA'
         AGO   .DCBLOOP
.DSORG@  DDD0  6,=Y(X'3C',1,2),2,&C,'DCB=DSORG=XL2 AT &C'
         AGO   .DCBLOOP
.DSORGX  AIF   ('&D' NE 'EROPT').EROPTX
         AIF   (&@).EROPT@
         AIF   ('&C' NE 'ACC').EROPTA
         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'80'),,,'DCB=EROPT=ACC'
         AGO   .DCBLOOP
.EROPTA  AIF   ('&C' NE 'SKP').EROPTB
         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'40'),,,'DCB=EROPT=SKP'
         AGO   .DCBLOOP
.EROPTB  AIF   ('&C' NE 'ABE').EROPTC
         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'20'),,,'DCB=EROPT=ABE'
         AGO   .DCBLOOP
.EROPTC  AIF   ('&C' NE 'T').ERREROP
         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'10'),,,'DCB=EROPT=T'
         AGO   .DCBLOOP
.EROPT@  DDD0  6,=Y(X'3D',1,1),1,&C,'DCB=EROPT=XL1 AT &C'
         AGO   .DCBLOOP
.EROPTX  AIF   ('&D' NE 'LIMCT').ERRDCB
         AIF   (&@).LIMCT@
         DDD0  9,=AL3(X'004100',X'010003',&C),,,'DCB=LIMCT=&C'
         AGO   .DCBLOOP
.LIMCT@  DDD0  6,=Y(X'41',1,3),3,&C,'DCB=LIMCT=AL3 AT &C'
         AGO   .DCBLOOP
.DCB7    AIF   ('&C'(1,7) NE 'KEYLEN=').DCB5
&C       SETC  '&C'(8,K'&C-7)
         AIF   (&@).KEYLEN@
         DDD0  7,=AL1(0,X'40',0,1,0,1,&C),,,'DCB=KEYLEN=&C'
         AGO   .DCBLOOP
.KEYLEN@ DDD0  6,=Y(X'40',1,1),1,&C,'DCB=KEYLEN=AL1 AT &C'
         AGO   .DCBLOOP
.DCB5    AIF   ('&C'(1,5) NE 'BUFL=').DCB4
&C       SETC  '&C'(6,K'&C-5)
         AIF   (&@).BUFL@
         DDD0  8,=Y(X'32',1,2,&C),,,'DCB=BUFL=&C'
         AGO   .DCBLOOP
.BUFL@   DDD0  6,=Y(X'32',1,2),2,&C,'DCB=BUFL=AL2 AT &C'
         AGO   .DCBLOOP
.DCB4    AIF   ('&C'(4,1) NE '=').DCBREF
&D       SETC  '&C'(1,3)
&C       SETC  '&C'(5,K'&C-4)
         AIF   ('&D' NE 'DEN').DCBDENX
         AIF   (&@).DEN@
         AIF   ('&C' NE '4').DEN3
         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'D3'),,,'DCB=DEN=4'
         AGO   .DCBLOOP
.DEN3    AIF   ('&C' NE '3').DEN2
         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'C3'),,,'DCB=DEN=3'
         AGO   .DCBLOOP
.DEN2    AIF   ('&C' NE '2').DEN1
         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'83'),,,'DCB=DEN=2'
         AGO   .DCBLOOP
.DEN1    AIF   ('&C' NE '1').DEN0
         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'43'),,,'DCB=DEN=1'
         AGO   .DCBLOOP
.DEN0    AIF   ('&C' NE '0').ERRDEN
         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'03'),,,'DCB=DEN=0'
         AGO   .DCBLOOP
.DEN@    DDD0  6,=Y(X'3B',1,1),1,&C,'DCB=DEN=XL1 AT &C'
         AGO   .DCBLOOP
.DCBDENX AIF   ('&D' NE 'NCP').ERRDCB
         AIF   (&@).NCP@
         DDD0  7,=AL1(0,X'44',0,1,0,1,&C),,,'DCB=NCP=&C'
         AGO   .DCBLOOP
.NCP@    DDD0  6,=Y(X'44',1,1),1,&C,'DCB=NCP=AL1 AT &C'
         AGO   .DCBLOOP
.DCBREF  AIF   (&A NE 1).ERRDCB2  POSITIONAL PARAMETER
         AIF   ('&C'(1,2) NE '*.').REFDSN
&C       SETC  '&C'(3,K'&C-2)
         AIF   (&@).DCBDDN@
         DDD0  X'002D0001',&C,8,,'DCB=*.&C'
         AGO   .DCBLOOP
.DCBDDN@ DDD0  6,=Y(X'2D',1,8),8,&C,'DCB=*.CL8 AT &C'
         AGO   .DCBLOOP
.REFDSN  MNOTE *,'*,* DATASET REFERENCE ASSUMED IN DCB=&C'
         AIF   (&@).DCBDSN@
         DDD0  X'002C0001',&C,44,,'DSNAME REFERENCE  DCB=&C'
         AGO   .DCBLOOP
.DCBDSN@ DDD0  6,=Y(X'2C',1,44),44,&C,'DSNAME REFERENCE  DCB=CL44 AT &C*
               '
         AGO   .DCBLOOP
.DCBX    AIF   ('&SUBSYS' EQ '').SUBSYSX
&C       SETC  '&SUBSYS(1)'
&K       SETA  K'&C
         AIF   ('&C' EQ '').SUB1X
         AIF   ('&C'(&K,1) NE '@').SUB1@X
&C       SETC  '&C'(1,&K-1)
         DDD0  6,=Y(X'5F',1,4),4,&C,'SUBSYS=(CL4 AT &C)'
         AGO   .SUB1X
.SUB1@X  DDD0  X'005F0001',&C,4,,'SUBSYS=(&C)'
.SUB1X   ANOP
&A       SETA  N'&SUBSYS+1
         AIF   (&A LE 2).SUBSYSX
         SPACE 1
.ALOOP   AIF   (&A LE 2).AX
&A       SETA  &A-1
&D       SETC  '&SUBSYS(&A)   '
         AIF   ('&D'(1,1) NE '''').DX
&D       SETC  '&D'(2,K'&D-5).'   '
.DX      ANOP
&K       SETA  K'&D-3
         AIF   ('&D'(&K,1) EQ '@').ERRSUB@
.ERRSUBX ANOP
&M       SETA  0
&M1      SETA  0
.M2LOOP  AIF   (&M1 GE 2).M2X
&M1      SETA  &M1+1
&M       SETA  &M+1
         AIF   ('&D'(&M,2) NE '''''' AND '&D'(&M,2) NE '&&').M2LOOP
&K       SETA  &K-1
&M       SETA  &M+1
         AGO   .M2LOOP
.M2X     ANOP
&C       SETC  '&D'(1,&M)
.LLOOP   AIF   (&M GE K'&D-3).LX
&L       SETA  &M+1
&M1      SETA  0
.M4LOOP  AIF   (&M1 GE 4).M4X
&M1      SETA  &M1+1
&M       SETA  &M+1
         AIF   ('&D'(&M,2) NE '''''' AND '&D'(&M,2) NE '&&').M4LOOP
&K       SETA  &K-1
&M       SETA  &M+1
         AGO   .M4LOOP
.M4X     ANOP
&C       SETC  '&C'',C'''.'&D'(&L,&M-&L+1)
         AGO   .LLOOP
.LX      AIF   (&K GT 67).ERRK67
.K67X    ANOP
&L       SETA  &K+2
&Y       SETA  &Y+&L
         MVC   ALOBLOCK-&Y.(&L),=A(&K*X'10000'+C'&C')
         AGO   .ALOOP
.AX      ANOP
&A       SETA  N'&SUBSYS-1
&Y       SETA  &Y+4
         MVC   ALOBLOCK-&Y.(4),=Y(X'60',&A)
         DDD0  ALOBLOCK-&Y,,,,'SUBSYS=(, )'
.SUBSYSX MEXIT
.ERRDUMM MNOTE 8,'INVALID POSITIONAL PARAMETER, &DUMMY.. IGNORED.'
         AGO   .DUMMYX
.ERREROP MNOTE 8,'INVALID EROPT, &C.. IGNORED.'
         AGO   .DCBLOOP
.ERRRECF MNOTE 8,'INVALID CHAR &D IN RECFM=&C.. RECFM IGNORED.'
         AGO   .DCBLOOP
.ERROPTC MNOTE 8,'INVALID CHAR &D IN OPTCD=&C.. OPTCD IGNORED.'
         AGO   .DCBLOOP
.ERRDCB2 MNOTE 8,'INVALID DCB PARAMETER, &C.. IGNORED.'
         AGO   .DCBLOOP
.ERRDCB  MNOTE 8,'INVALID DCB PARAMETER, &D=&C.. IGNORED.'
         AGO   .DCBLOOP
.ERRDSOR MNOTE 8,'DSORG=&C NOT SUPPORTED. IGNORED.'
         AGO   .DCBLOOP
.ERRDEN  MNOTE 8,'DEN=&C INVALID. IGNORED.'
         AGO   .DCBLOOP
.ERRSUB@ ANOP
&C       SETC  '&D'(1,&K)
         MNOTE *,'*,* SUBSYSTEM PARAMETER, ''&C'', TAKEN AS LITERAL'
         AGO   .ERRSUBX
.ERRK67  ANOP
&D       SETC  '&D'(1,K'&D-3)
         MNOTE 8,'SUBSYSTEM SUBPARAMETER, ''&D'', EXCEEDS 67 CHARACTERS*
               . TRUNCATED.'
&K       SETA  67
         AGO   .K67X
         MEND
./ ADD NAME=DDD4     0100-03065-03065-2223-00220-00220-00000-DYNALLC
         MACRO
         DDD4  &SYSOUT,&DEST,&HOLD,&COPIES,&OUTLIM,&FCB,&UCS,          *
               &BURST,&CHARS,&FLASH,&MODIFY
         LCLA  &A,&K
         LCLC  &C,&D
         AIF   ('&SYSOUT' EQ '').SYSOUTX
         AIF   (N'&SYSOUT GT 3).ERRSYS9
&C       SETC  '&SYSOUT(1)'
         AIF   ('&C' EQ '').SYSOU1X
         AIF   ('&C' NE '*').SYSOUT1
         DDD0  =Y(X'18',0),,,,'SYSOUT=*'
         AGO   .SYSOU1X
.SYSOUT1 AIF   ('&C'(K'&C,1) NE '@').SYSO1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'18',1,1),1,&C,'SYSOUT=CL1 AT &C'
         AGO   .SYSOU1X
.SYSO1@X DDD0  X'00180001',&C,1,,'SYSOUT=&C'
.SYSOU1X AIF   (N'&SYSOUT LT 2).SYSOUTX
&C       SETC  '&SYSOUT(2)'
         AIF   ('&C' EQ '').SYSOU2X
         AIF   ('&C'(K'&C,1) NE '@').SYSO2@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'19',1,8),8,&C,'SYSOUT=(,CL8 AT &C)'
         AGO   .SYSOU2X
.SYSO2@X DDD0  X'00190001',&C,8,,'SYSOUT=(,&C)'
.SYSOU2X AIF   ('&SYSOUT(3)' EQ '').SYSOUTX
&C       SETC  '&SYSOUT(3)'
         AIF   ('&C'(K'&C,1) NE '@').SYSO3@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'1A',1,4),4,&C,'SYSOUT=(,,CL4 AT &C)'
         AGO   .SYSOUTX
.SYSO3@X DDD0  X'001A0001',&C,4,,'SYSOUT=(,,&C)'
.SYSOUTX AIF   ('&DEST' EQ '').DESTX
&C       SETC  '&DEST'
         AIF   ('&C'(K'&C,1) NE '@').DEST@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'58',1,7),7,&C,'DEST=CL7 AT &C'
         AGO   .DESTX
.DEST@X  DDD0  X'00580001',&C,7,,'DEST=&C'
.DESTX   AIF   ('&HOLD' EQ '' OR '&HOLD' EQ 'NO').HOLDX
         AIF   ('&HOLD' NE 'YES').ERRHOLD
         DDD0  =Y(X'59',0),,,,'HOLD=YES'
.HOLDX   AIF   ('&COPIES' EQ '').COPIESX
         AIF   (N'&COPIES GT 2).ERRCOP9
&C       SETC  '&COPIES(1)'
         AIF   ('&C' EQ '').COPIE1X
         AIF   ('&C'(K'&C,1) NE '@').COPIE@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'1D',1,1),1,&C,'COPIES=AL1 AT &C'
         AGO   .COPIE1X
.COPIE@X DDD0  7,=AL1(0,X'1D',0,1,0,1,&C),,,'COPIES=&C'
.COPIE1X AIF   (N'&COPIES LT 2).COPIESX
&C       SETC  '&COPIES(2)'
         AIF   ('&C'(1,1) EQ '(').COPIES2
         DDD0  7,=AL1(0,X'66',0,1,0,1,&C),,,'COPIES=(,&C)  GROUP VALUE'
         AGO   .COPIESX
.COPIES2 ANOP
&A       SETA  2
.COPLOOP AIF   ('&C'(&A,1) EQ ',').COPLOPX
&A       SETA  &A+1
         AIF   (&A LT K'&C).COPLOOP
.COPLOPX ANOP
&D       SETC  '&D,0,1,'.'&C'(2,&A-2)
&C       SETC  '&C'(&A,K'&C-&A+1)
&K       SETA  &K+1
         AIF   (K'&C GT 1).COPIES2
&A       SETA  &K*3+4
         DDD0  &A,=AL1(0,X'66',0,&K&D),,,'COPIES=(,&COPIES(2))  GROUP V*
               ALUES'
.COPIESX AIF   ('&OUTLIM' EQ '').OUTLIMX
         AIF   ('&OUTLIM'(K'&OUTLIM,1) NE '@').OUTLI@X
&C       SETC  '&OUTLIM'(1,K'&OUTLIM-1)
         DDD0  6,=Y(X'1B',1,3),3,&C,'OUTLIM=AL3 AT &C'
         AGO   .OUTLIMX
.OUTLI@X DDD0  9,=AL3(X'001B00',X'010003',&OUTLIM),,,'OUTLIM=&OUTLIM'
.OUTLIMX AIF   ('&FCB' EQ '').FCBX
         AIF   (N'&FCB GT 2).ERRFCB9
&C       SETC  '&FCB(1)'
         AIF   ('&C' EQ '').FCB1X
         AIF   ('&C'(K'&C,1) NE '@').FCB1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'25',1,4),4,&C,'FCB=(CL4 AT &C)'
         AGO   .FCB1X
.FCB1@X  DDD0  X'00250001',&FCB(1),4,,'FCB=(&FCB(1))'
.FCB1X   AIF   ('&FCB(2)' EQ '').FCBX
&C       SETC  '&FCB(2)'
         AIF   ('&C' NE 'VERIFY').FCB2A
         DDD0  7,=AL1(0,X'26',0,1,0,1,X'04'),,,'FCB=(,VERIFY)'
         AGO   .FCBX
.FCB2A   AIF   ('&C' NE 'ALIGN').FCB2@
         DDD0  7,=AL1(0,X'26',0,1,0,1,X'08'),,,'FCB=(,ALIGN)'
         AGO   .FCBX
.FCB2@   AIF   ('&C'(K'&C,1) NE '@').ERRFCB
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'26',1,1),1,&C,'FCB=(,XL1 AT &C)'
.FCBX    AIF   ('&UCS' EQ '').UCSX
         AIF   (N'&UCS GT 3).ERRUCS9
&C       SETC  '&UCS(1)'
         AIF   ('&C' EQ '').UCS1X
         AIF   ('&C'(K'&C,1) NE '@').UCS1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'29',1,4),4,&C,'UCS=(CL4 AT &C)'
         AGO   .UCS1X
.UCS1@X  DDD0  X'00290001',&C,4,,'UCS=(&C)'
.UCS1X   AIF   ('&UCS(2)' EQ '').UCS2X
         AIF   ('&UCS(2)' NE 'FOLD').ERRUCS2
         DDD0  =Y(X'2A',0),,,,'UCS=(,FOLD)'
.UCS2X   AIF   ('&UCS(3)' EQ '').UCSX
         AIF   ('&UCS(3)' NE 'VERIFY').ERRUCS3
         DDD0  =Y(X'2B',0),,,,'UCS=(,,VERIFY)'
.UCSX    AIF   ('&BURST' EQ '').BURSTX
         AIF   ('&BURST' NE 'YES' AND '&BURST' NE 'Y').BURSTYX
         DDD0  7,=AL1(0,X'64',0,1,0,1,X'02'),,,'BURST=&BURST'
         AGO   .BURSTX
.BURSTYX AIF   ('&BURST' NE 'NO' AND '&BURST' NE 'N').BURSTNX
         DDD0  7,=AL1(0,X'64',0,1,0,1,X'04'),,,'BURST=&BURST'
         AGO   .BURSTX
.BURSTNX AIF   ('&BURST'(K'&BURST,1) NE '@').ERRBURS
&C       SETC  '&BURST'(1,K'&BURST-1)
         DDD0  6,=Y(X'64',1,1),1,&C,'BURST=XL1 AT &C'
.BURSTX  AIF   ('&CHARS' EQ '').CHARSX
         AIF   (N'&CHARS GT 1).CHARMUL
&C       SETC  '&CHARS(1)'
         AIF   ('&C'(K'&C,1) NE '@').CHARS@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'65',1,4),4,&C,'CHARS=CL4 AT &C'
         AGO   .CHARSX
.CHARS@X DDD0  X'00650001',&C,4,,'CHARS=&CHARS'
         AGO   .CHARSX
.CHARMUL AIF   (N'&CHARS GT 4).ERRCHA9
&C       SETC  ''
.CHLOOP  ANOP
&A       SETA  &A+1
         AIF   (K'&CHARS(&A) LT 1).ERRCHA1
         AIF   ('&CHARS(&A)'(K'&CHARS(&A),1) EQ '@').ERRCHA@
         AIF   (K'&CHARS(&A) GT 4).ERRCHA4
&C       SETC  '&C,4,C'''.'&CHARS(&A) '(1,2).''',C'''.'&CHARS(&A)   '(3*
               ,2).''''
         AIF   (&A LT N'&CHARS).CHLOOP
&C       SETC  '&A&C'
&A       SETA  &A*6+4
         DDD0  &A,=AL2(X'65',&C),,,'CHARS=&CHARS'
.CHARSX  AIF   ('&FLASH' EQ '').FLASHX
         AIF   (N'&FLASH GT 2).ERRFLS9
&C       SETC  '&FLASH(1)'
         AIF   ('&C' EQ '').FLASH1X
         AIF   ('&C'(K'&C,1) NE '@').FLAS1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'67',1,4),4,&C,'UCS=(CL4 AT &C)'
         AGO   .FLASH1X
.FLAS1@X DDD0  X'00670001',&C,4,,'FLASH=(&C)'
.FLASH1X AIF   (N'&FLASH LT 2).FLASHX
&C       SETC  '&FLASH(2)'
         AIF   ('&C'(K'&C,1) NE '@').FLSH2@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'68',1,1),1,&C,'FLASH=(,AL1 AT &C)  FORMS OVERLAY *
               COUNT'
         AGO   .FLASHX
.FLSH2@X DDD0  7,=AL1(0,X'68',0,1,0,1,&C),,,'FLASH=(,&C)  FORMS OVERLAY*
                COUNT'
.FLASHX  AIF   ('&MODIFY' EQ '').MODIFYX
         AIF   (N'&MODIFY GT 2).ERRMOD9
&C       SETC  '&MODIFY(1)'
         AIF   ('&C' EQ '').MODIF1X
         AIF   ('&C'(K'&C,1) NE '@').MODI1@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'69',1,4),4,&C,'MODIFY=(CL4 AT &C)'
         AGO   .MODIF1X
.MODI1@X DDD0  X'00690001',&C,4,,'MODIFY=(&C)'
.MODIF1X AIF   (N'&MODIFY LT 2).MODIFYX
&C       SETC  '&MODIFY(2)'
         AIF   ('&C'(K'&C,1) NE '@').MODI2@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'6A',1,1),1,&C,'MODIFY=(,XL1 AT &C)  TABLE REFEREN*
               CE CHARACTER'
         AGO   .MODIFYX
.MODI2@X DDD0  7,=AL1(0,X'6A',0,1,0,1,&C),,,'MODIFY=(,&C)  TABLE REFERE*
               NCE CHARACTER'
.MODIFYX MEXIT
.ERRSYS9 MNOTE 8,'ONLY THREE SUBPARAMETERS ALLOWED IN SYSOUT=&SYSOUT.. *
               SYSOUT IGNORED.'
         AGO   .SYSOUTX
.ERRHOLD MNOTE 8,'HOLD=&HOLD INVALID. HOLD IGNORED.'
         AGO   .HOLDX
.ERRCOP9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN COPIES=&COPIES.. CO*
               PIES IGNORED.'
         AGO   .COPIESX
.ERRFCB9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN FCB=&FCB.. FCB IGNO*
               RED.'
         AGO   .FCBX
.ERRFCB  MNOTE 8,'INVALID VALUE, FCB=(,&C). IGNORED.'
         AGO   .FCBX
.ERRUCS9 MNOTE 8,'ONLY THREE SUBPARAMETERS ALLOWED IN UCS=&UCS.. UCS IG*
               NORED.'
         AGO   .UCSX
.ERRUCS2 MNOTE 8,'INVALID VALUE, UCS=(,&UCS(2)). IGNORED.'
         AGO   .UCS2X
.ERRUCS3 MNOTE 8,'INVALID VALUE, UCS=(,,&UCS(3)). IGNORED.'
         AGO   .UCSX
.ERRBURS MNOTE 8,'BURST=&BURST INVALID. BURST IGNORED.'
         AGO   .BURSTX
.ERRCHA1 MNOTE 8,'NULL SUBPARAMETER IN CHARS=&CHARS NOT ALLOWED. CHARS *
               IGNORED.'
         AGO   .CHARSX
.ERRCHA@ MNOTE 8,'ONLY ONE CHARACTER ARRANGEMENT TABLE NAME MAY BE SPEC*
               IFIED WHEN USING ''@''. CHARS=&CHARS IGNORED.'
         AGO   .CHARSX
.ERRCHA4 MNOTE 8,'CHARACTER ARRANGEMENT TABLE NAMES MUST BE ONE TO FOUR*
                CHARACTERS LONG. CHARS=&CHARS IGNORED.'
         AGO   .CHARSX
.ERRCHA9 MNOTE 8,'ONLY FOUR SUBPARAMETERS ALLOWED IN CHARS=&CHARS.. CHA*
               RS IGNORED.'
         AGO   .CHARSX
.ERRFLS9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN FLASH=&FLASH.. FLAS*
               H IGNORED.'
         AGO   .FLASHX
.ERRMOD9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN MODIFY=&MODIFY.. MO*
               DIFY IGNORED.'
         AGO   .MODIFYX
         MEND
./ ADD NAME=DDD5     0100-03065-03065-2223-00110-00110-00000-DYNALLC
         MACRO
         DDD5  &DDNAME,&DSN,&DSNAME,&DISP
         GBLB  &RTDDN,&CONCATB
         LCLA  &A,&X
         LCLC  &C,&D
         AIF   ('&DDNAME' EQ '' OR '&DDNAME' EQ 'RETURN').DDNAMEQ
         AIF   ('&DDNAME'(K'&DDNAME,1) NE '@').DDNAM@X
&C       SETC  '&DDNAME'(1,K'&DDNAME-1)
         DDD0  6,=Y(X'01',1,8),8,&C,'DDNAME CL8 AT &C'
         AGO   .DDNAMEQ
.DDNAM@X DDD0  X'00010001',&DDNAME,8,,'DDNAME IS &DDNAME'
.DDNAMEQ AIF   (NOT &CONCATB AND '&DDNAME' NE 'RETURN').DDNAMEX
         MVC   ALORTDDN(14),=Y(X'55',1,8,C'  ',C'  ',C'  ',C'  ')
         DDD0  ALORTDDN,,,,'RETURN THE DDNAME'
&RTDDN   SETB  1
.DDNAMEX AIF   ('&DSN&DSNAME' EQ '').DSNAMEX
&C       SETC  '&DSN'
         AIF   ('&DSNAME' EQ '').DSNAMEB
         AIF   ('&DSN' NE '').ERRDSN
&C       SETC  '&DSNAME'
.DSNAMEB AIF   ('&C'(1,1) EQ '*').ERRDREF
&A       SETA  K'&C
         AIF   ('&C'(&A,1) NE ')').DSNAME
.MEMLOOP AIF   (&A LE 1).ERRMEM
&A       SETA  &A-1
         AIF   ('&C'(&A,1) NE ')').PARENX
&X       SETA  &X+1
.PARENX  AIF   ('&C'(&A,1) NE '(').MEMLOOP
&X       SETA  &X-1
         AIF   (&X GE 0).MEMLOOP
&D       SETC  '&C'(&A+1,K'&C-&A-1)
         AIF   ('&D'(K'&D,1) NE '@').MEMBE@X
&D       SETC  '&D'(1,K'&D-1)
         DDD0  6,=Y(X'03',1,8),8,&D,'DSN=...(CL8 AT &D)'
         AGO   .MEMBERX
.MEMBE@X DDD0  X'00030001',&D,8,,'DSN=...(&D)'
.MEMBERX AIF   (&A  EQ 1).DSNAMEX
&C       SETC  '&C'(1,&A-1)
.DSNAME  AIF   ('&C'(K'&C,1) NE '@').DSNAM@X
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'02',1,44),44,&C,'DSNAME=CL44 AT &C'
         AGO   .DSNAMEX
.DSNAM@X DDD0  X'00020001',&C,44,,'DSN=&C'
.DSNAMEX AIF   ('&DISP' EQ '').DISPX
&C       SETC  '&DISP(1)'
         AIF   ('&C' EQ '').STATUSX
         AIF   ('&C' NE 'SHR' AND '&C' NE 'SHARE').STATUSA
         DDD0  7,=AL1(0,X'04',0,1,0,1,X'08'),,,'DISP=(&C)'
         AGO   .STATUSX
.STATUSA AIF   ('&C' NE 'OLD').STATUSB
         DDD0  7,=AL1(0,X'04',0,1,0,1,X'01'),,,'DISP=(OLD)'
         AGO   .STATUSX
.STATUSB AIF   ('&C' NE 'NEW').STATUSC
         DDD0  7,=AL1(0,X'04',0,1,0,1,X'04'),,,'DISP=(NEW)'
         AGO   .STATUSX
.STATUSC AIF   ('&C' NE 'MOD').STATUSD
         DDD0  7,=AL1(0,X'04',0,1,0,1,X'02'),,,'DISP=(MOD)'
         AGO   .STATUSX
.STATUSD AIF   ('&C'(K'&C,1) NE '@').ERRSTA
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'04',1,1),1,&C,'DISP=(XL1 AT &C)'
.STATUSX AIF   ('&DISP(2)' EQ '').NDISPX
&C       SETC  '&DISP(2)'
         AIF   ('&C' NE 'CATLG').NDISPA
         DDD0  7,=AL1(0,X'05',0,1,0,1,X'02'),,,'DISP=(,CATLG)'
         AGO   .NDISPX
.NDISPA  AIF   ('&C' NE 'DELETE').NDISPK
         DDD0  7,=AL1(0,X'05',0,1,0,1,X'04'),,,'DISP=(,DELETE)'
         AGO   .NDISPX
.NDISPK  AIF   ('&C' NE 'KEEP').NDISPU
         DDD0  7,=AL1(0,X'05',0,1,0,1,X'08'),,,'DISP=(,KEEP)'
         AGO   .NDISPX
.NDISPU  AIF   ('&C' NE 'UNCATLG').NDISP@
         DDD0  7,=AL1(0,X'05',0,1,0,1,X'01'),,,'DISP=(,UNCATLG)'
         AGO   .NDISPX
.NDISP@  AIF   ('&C'(K'&C,1) NE '@').ERRNDIS
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'05',1,1),1,&C,'DISP=(,XL1 AT &C)'
.NDISPX  AIF   ('&DISP(3)' EQ '').DISPX
&C       SETC  '&DISP(3)'
         AIF   ('&C' NE 'CATLG').CDISPA
         DDD0  7,=AL1(0,X'06',0,1,0,1,X'02'),,,'DISP=(,,CATLG)'
         AGO   .DISPX
.CDISPA  AIF   ('&C' NE 'DELETE').CDISPB
         DDD0  7,=AL1(0,X'06',0,1,0,1,X'04'),,,'DISP=(,,DELETE)'
         AGO   .DISPX
.CDISPB  AIF   ('&C' NE 'KEEP').CDISPU
         DDD0  7,=AL1(0,X'06',0,1,0,1,X'08'),,,'DISP=(,,KEEP)'
         AGO   .DISPX
.CDISPU  AIF   ('&C' NE 'UNCATLG').CDISP@
         DDD0  7,=AL1(0,X'06',0,1,0,1,X'01'),,,'DISP=(,,UNCATLG)'
         AGO   .DISPX
.CDISP@  AIF   ('&C'(K'&C,1) NE '@').ERRCDIS
&C       SETC  '&C'(1,K'&C-1)
         DDD0  6,=Y(X'06',1,1),1,&C,'DISP=(,,XL1 AT &C)'
.DISPX   MEXIT
.ERRDSN  MNOTE 12,'BOTH DSN= AND DSNAME= SPECIFIED. BOTH IGNORED.'
         AGO   .DSNAMEX
.ERRDREF MNOTE 8,'DSNAME BY DDNAME REFERENCE IN DSN=&C NOT SUPPORTED BY*
                DYNAMIC ALLOCATION. DSN IGNORED.'
         AGO   .DSNAMEX
.ERRMEM  MNOTE 12,'INVALID DSNAME, &C'
         AGO   .DSNAMEX
.ERRSTA  MNOTE 12,'INVALID FIRST DISP PARAMETER, &C'
         AGO   .STATUSX
.ERRNDIS MNOTE 12,'INVALID SECOND DISP PARAMETER, &C'
         AGO   .NDISPX
.ERRCDIS MNOTE 12,'INVALID THIRD DISP VALUE, &C'
         AGO   .DISPX
         MEND
./ ADD NAME=DDI      0100-03065-03065-2223-00093-00093-00000-DYNALLC
         MACRO
&DDNAME  DDI   &DISP=,                                                 *
               &KEYADDS=,&EXIT=ALODFAIL
         GBLA  &X,&Y,&H,&N,&R
         GBLB  &DDDFAIL,&DDDD
         LCLA  &A,&AD1,&AD2,&AD3
         LCLC  &C,&CD1,&CD2,&CD3
         AIF   (&DDDD).ERRDDDD
&X       SETA  20 DISPLACEMENT FROM ALOBLOCK TO FIRST TEXT UNIT POINTER
&Y       SETA  20         NEGATIVE DISTANCE FROM ALOBLOCK TO FIRST DATA
&R       SETA  14                      FIRST REGISTER LOADED
         DDD5  &DDNAME
         AIF   ('&DISP' EQ '').DISPX
&C       SETC  '&DISP(1)'
         AIF   ('&C' EQ '').DISP1X
         AIF   ('&C'(K'&C,1) EQ '@').DISP1@
         MNOTE 8,'DISP=( ) MUST BE INDIRECT ADDRESS. DISP=(&C) IGNORED.*
               '
         AGO   .DISP1X
.DISP1@  ANOP
&CD1     SETC  '&C'(1,K'&C-1)
         DDD0  7,=AL1(0,X'07',0,1,0,1,0),,,                            *
               'DISP=(XL1 RETURNED AT &CD1)'
&AD1     SETA  &Y-6
.DISP1X  ANOP
&C       SETC  '&DISP(2)'
         AIF   ('&C' EQ '').DISP2X
         AIF   ('&C'(K'&C,1) EQ '@').DISP2@
         MNOTE 8,'DISP=(, ) MUST BE INDIRECT ADDRESS. DISP=(,&C) IGNORE*
               D.'
         AGO   .DISP2X
.DISP2@  ANOP
&CD2     SETC  '&C'(1,K'&C-1)
         DDD0  7,=AL1(0,X'08',0,1,0,1,0),,,                            *
               'DISP=(,XL1 RETURNED AT &CD2)'
&AD2     SETA  &Y-6
.DISP2X  ANOP
&C       SETC  '&DISP(3)'
         AIF   ('&C' EQ '').DISPX
         AIF   ('&C'(K'&C,1) EQ '@').DISP3@
         MNOTE 8,'DISP=(,, ) MUST BE INDIRECT ADDRESS. DISP=(,,&C) IGNO*
               RED.'
         AGO   .DISPX
.DISP3@  ANOP
&CD3     SETC  '&C'(1,K'&C-1)
         DDD0  7,=AL1(0,X'09',0,1,0,1,0),,,                            *
               'DISP=(,,XL1 RETURNED AT &CD3)'
&AD3     SETA  &Y-6
.DISPX   AIF   ('&KEYADDS' EQ '').KEYADDX
&A       SETA  0
.KEYLOOP AIF   (&A GE N'&KEYADDS).KEYADDX
&A       SETA  &A+1
&C       SETC  '&KEYADDS(&A)'
         AIF   ('&C' EQ '').KEYLOOP
         AIF   ('&C'(1,1) EQ '(').KEYADDR
         DDD0  &C,,,,'KEYADDS=&C'
         AGO   .KEYLOOP
.KEYADDR DDD0  0&C,,,,'KEYADDS=&C'
         AGO   .KEYLOOP
.KEYADDX AIF   (&R NE 14).R14X
&X       SETA  &X-4
         AGO   .RX
.R14X    AIF   (&R NE 15).R15X
         ST    14,ALOBLOCK+&X
         AGO   .RX
.R15X    AIF   (&R NE 0).R0X
         STM   14,15,ALOBLOCK+&X
&X       SETA  &X+4
         AGO   .RX
.R0X     STM   14,0,ALOBLOCK+&X
&X       SETA  &X+8
.RX      OI    ALOBLOCK+&X,X'80'        SET END OF TEXT UNIT ADDR LIST
         LA    0,X'0700'                LOAD VERB, FLAGS1
         AIF   ('&EXIT'(1,1) EQ '(').LREXIT
&DDDFAIL SETB  ('&EXIT' EQ 'ALODFAIL' OR &DDDFAIL)
         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
         AGO   .BALDDDD
.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO
         SPACE 1
         AIF   (&AD1 EQ 0).D1X
         MVC   &CD1.(1),ALOBLOCK-&AD1
.D1X     AIF   (&AD2 EQ 0).D2X
         MVC   &CD2.(1),ALOBLOCK-&AD2
.D2X     AIF   (&AD3 EQ 0).D3X
         MVC   &CD3.(1),ALOBLOCK-&AD3
.D3X     AIF   (&H GE &Y).HX
&H       SETA  &Y
.HX      AIF   (&N GE &X).NX
&N       SETA  &X
.NX      MEXIT
.ERRDDDD MNOTE 12,'DDI MAY NOT BE ISSUED AFTER DDDD'
         MEND
./ ADD NAME=DDTU     0100-03065-03065-2223-00271-00271-00000-DYNALLC
         MACRO                                                          01675
&DDNAME  DDTU  &DUMMY,&DSN=,&DSNAME=,&DISP=,&TERM=,&FREE=,             *01676*92
               &UNIT=,&SPACE=,&MSVGP=,&VOL=,&LABEL=,&PROTECT=,         *01677*92
               &DCB=,&SUBSYS=,                                         *01678*92
               &SYSOUT=,&DEST=,&HOLD=,&COPIES=,&OUTLIM=,&FCB=,&UCS=,   *01679*90
               &PASWORD=                                                01680*90
         LCLA  &K,&A                                                    01681*53
         LCLB  &B0,&B1,&B2,&B3,&B4,&B5,&B6                              01682*90
         LCLC  &C,&D                                                    01683
         AIF   ('&DDNAME' EQ '' OR '&DDNAME' EQ 'RETURN').DDNAMEQ       01684*90
&DDNAME  DC    Y(X'01',1,8)            DDNAME                           01685*92
.DDNAMEQ AIF   ('&DDNAME' NE 'RETURN').DDNAMEX                          01686*90
RETURN   DC    Y(X'55',1,8)            RETURN THE DDNAME                01687*90
.DDNAMEX AIF   ('&DSN&DSNAME' EQ '').DSNAMEX                            01688*90
&C       SETC  '&DSN'                                                   01689*90
         AIF   ('&DSNAME' EQ '').DSNAMEB                                01690*90
         AIF   ('&DSN' NE '').ERRDSN                                    01691*90
&C       SETC  '&DSNAME'                                                01692*90
.DSNAMEB ANOP                                                           01693*90
&A       SETA  K'&C                                                     01694*90
         AIF   ('&C'(&A,1) NE ')').DSNAME                               01695*90
.MEMLOOP AIF   (&A LE 1).ERRMEM                                         01696*92
&A       SETA  &A-1                                                     01697*90
         AIF   ('&C'(&A,1) NE '(').MEMLOOP                              01698*90
&D       SETC  '&C'(&A+1,K'&C-&A-1)                                     01699*92
&D       DC    Y(X'03',1,8)            DSN=...( )                       01700*92
&C       SETC  '&C'(1,&A-1)                                             01701*92
.DSNAME  AIF   ('&C' EQ '').DSNAMEX                                     01702*90
&C       DC    Y(X'02',1,44)           DSN=                             01703*92
.DSNAMEX AIF   ('&DISP' EQ '').DISPX                                    01704*90
         AIF   ('&DISP(1)' EQ '').STATUSX                               01705*90
&DISP(1) DC    Y(X'04',1,1)             DISP=( )                        01706*92
.STATUSX AIF   ('&DISP(2)' EQ '').NDISPX                                01707*90
&DISP(2) DC    Y(X'05',1,1)             DISP=(, )                       01708*92
.NDISPX  AIF   (N'&DISP LT 3).DISPX                                     01709*90
&DISP(3) DC    Y(X'06',1,1)             DISP=(,, )                      01710*92
.DISPX   AIF   ('&TERM' EQ '').TERMX                                    01711*90
&TERM    DC    Y(X'28',0)              TERM=TS                          01712*90
.TERMX   AIF   ('&FREE' EQ '').FREEX                                    01713*90
&FREE    DC    Y(X'1C',0)              FREE=CLOSE                       01714*90
.FREEX   AIF   ('&UNIT&SPACE&MSVGP' EQ '').DDD1X                        01715*90
         AIF   ('&UNIT' EQ '').UNITX                                    01716*90
         AIF   ('&UNIT(1)' EQ '').UNIT1X                                01717*90
&UNIT(1) DC    Y(X'15',1,8)            UNIT=( )                         01718*90
.UNIT1X  AIF   ('&UNIT(2)' EQ '').UNIT2X                                01719*90
         AIF   ('&UNIT(2)' NE 'P').UNITC                                01720*90
P        DC    Y(X'17',0)              UNIT=(,P)  PARALLEL MOUNT        01721*90
         AGO   .UNIT2X                                                  01722*90
.UNITC   ANOP                                                           01723*90
&UNIT(2) DC    Y(X'16',1,1)            UNIT=(, )  UNIT COUNT            01724*90
.UNIT2X  AIF   ('&UNIT(3)' EQ '').UNITX                                 01725*90
         MNOTE 8,'UNIT=(,,DEFER) NOT SUPPORTED BY DYNAMIC ALLOCATION.'  01726*90
.UNITX   AIF   ('&SPACE' EQ '').SPACEX                                  01727*90
&C       SETC  '&SPACE(1)'                                              01728*90
         AIF   ('&C' EQ '').SPACE2                                      01729*90
         AIF   ('&C' NE 'TRK').SPACE1C                                  01730*90
TRK      DC    Y(X'07',0)              SPACE=(TRK)                      01731*92
         AGO   .SPACE2                                                  01732*90
.SPACE1C AIF   ('&C' NE 'CYL').SPACE1A                                  01733*90
CYL      DC    Y(X'08',0)              SPACE=(CYL)                      01734*92
         AGO   .SPACE2                                                  01735*90
.SPACE1A ANOP                                                           01736*90
&C       DC    Y(X'09',1,3)            SPACE=( )                        01737*92
.SPACE2  AIF   ('&SPACE(2)' EQ '').SPACE2X                              01738*90
&C       SETC  '&SPACE(2)'                                              01739*90
         AIF   ('&C'(1,1) NE '(').SPACE2W                               01740*90
&K       SETA  2                                                        01741*90
.SPACE2A AIF   ('&C'(&K,1) EQ ',').SPACE2B                              01742*90
&K       SETA  &K+1                                                     01743*90
         AIF   (&K LT K'&C).SPACE2A                                     01744*90
.SPACE2B AIF   (&K EQ 2).SPACE2C                                        01745*92
&D       SETC  '&C'(2,&K-2)                                             01746*92
&D       DC    Y(X'0A',1,3)            SPACE=(,( ))                     01747*90
.SPACE2C AIF   (&K GE K'&C).SPACE2X                                     01748*90
&K       SETA  &K+1                                                     01749*90
&A       SETA  &K                                                       01750*90
.SPACE2D AIF   ('&C'(&K,1) EQ ',').SPACE2E                              01751*90
&K       SETA  &K+1                                                     01752*90
         AIF   (&K LT K'&C).SPACE2D                                     01753*90
.SPACE2E AIF   (&K EQ &A).SPACE2F                                       01754*90
&D       SETC  '&C'(&A,&K-&A)                                           01755*90
&D       DC    Y(X'0B',1,3)            SPACE=(,(, ))                    01756*90
.SPACE2F AIF   (&K GE K'&C).SPACE2X                                     01757*90
&K       SETA  &K+1                                                     01758*90
         AIF   (&K GE K'&C).SPACE2X                                     01759*90
&A       SETA  &K                                                       01760*90
.SPACE2G AIF   ('&C'(&K,1) EQ ',').ERRSPA2                              01761*90
&K       SETA  &K+1                                                     01762*90
         AIF   (&K LT K'&C).SPACE2G                                     01763*90
&D       SETC  '&C'(&A,&K-&A)                                           01764*90
&D       DC    Y(X'0C',1,3)            SPACE=(,(,, ))                   01765*90
         AGO   .SPACE2X                                                 01766*90
.SPACE2W ANOP                                                           01767*90
&C       DC    Y(X'0A',1,3)            SPACE=(,( ))                     01768*90
.SPACE2X AIF   (N'&SPACE LE 3).SPACE3                                   01769*90
&C       SETC  '&SPACE(5)'                                              01770*90
&D       SETC  '&SPACE(4)'                                              01771*90
         AIF   ('&C' EQ '').SPACE4                                      01772*90
&C       DC    Y(X'0F',0)              SPACE=(,,,,ROUND)                01773*90
.SPACE4  AIF   ('&D' EQ '').SPACE3                                      01774*90
&D       DC    Y(X'0E',1,1)            SPACE=(,,, )                     01775*90
.SPACE3  AIF   ('&SPACE(3)' EQ '').SPACEX                               01776*90
&C       SETC  '&SPACE(3)'                                              01777*90
&C       DC    Y(X'0D',0)              SPACE=(,,RLSE)                   01778*90
.SPACEX  AIF   ('&MSVGP' EQ '').MSVGPX                                  01779*90
&MSVGP   DC    Y(X'5E',1,8)            MSVGP=                           01780*90
.MSVGPX  ANOP                                                           01781*90
.DDD1X   AIF   ('&VOL&LABEL&PROTECT' EQ '').DDD2X                       01782*92
         AIF   ('&VOL' EQ '').VOLX                                      01783*90
&C       SETC  '&VOL(N'&VOL)'                                           01784*90
         AIF   ('&C'(1,4) NE 'SER=').VOLREF                             01785*90
&C       SETC  '&C'(5,K'&C-4)                                           01786*90
&C       DC    Y(X'10',1,6)            VOL=SER=                         01787*90
         AGO   .VOLKEYX                                                 01788*90
.VOLREF  AIF   ('&C'(1,4) NE 'REF=').VOL4                               01789*90
&C       SETC  '&C'(5,K'&C-4)                                           01790*90
&C       DC    Y(X'14',1,44)           VOL=REF=                         01791*90
.VOLKEYX AIF   (N'&VOL LE 1).VOLX                                       01792*90
         AIF   (N'&VOL LE 2).VOL2X                                      01793*90
         AIF   (N'&VOL LE 3).VOL3X                                      01794*90
         AIF   (N'&VOL LE 4).VOL4X                                      01795*90
.VOL4    AIF   ('&VOL(4)' EQ '').VOL4X                                  01796*90
&VOL(4)  DC    Y(X'13',1,1)            VOL=(,,, )                       01797*90
.VOL4X   AIF   ('&VOL(3)' EQ '').VOL3X                                  01798*90
&VOL(3)  DC    Y(X'12',1,2)            VOL=(,, )                        01799*90
.VOL3X   AIF   ('&VOL(2)' EQ '').VOL2X                                  01800*90
         MNOTE 8,'VOL=(,RETAIN) NOT SUPPORTED BY DYNAMIC ALLOCATION'    01801*90
.VOL2X   AIF   ('&VOL(1)' EQ '').VOLX                                   01802*90
&VOL(1)  DC    Y(X'11',0)              VOL=(PRIVATE)                    01803*90
.VOLX    AIF   ('&LABEL' EQ '').LABELX                                  01804*90
&C       SETC  '&LABEL(N'&LABEL)'                                       01805*90
         AIF   ('&C'(1,6) NE 'EXPDT=').LABELEX                          01806*90
&C       SETC  '&C'(7,K'&C-6)                                           01807*90
&C       DC    Y(X'22',1,5)            LABEL=EXPDT=                     01808*90
         AGO   .LABKEYX                                                 01809*90
.LABELEX AIF   ('&C'(1,6) NE 'RETPD=').LABELRX                          01810*90
&C       SETC  '&C'(7,K'&C-6)                                           01811*90
&C       DC    Y(X'23',1,2)            LABEL=RETPD=                     01812*90
.LABKEYX AIF   (N'&LABEL LE 1).LABELX                                   01813*90
         AIF   (N'&LABEL LE 2).LABEL2X                                  01814*90
         AIF   (N'&LABEL LE 3).LABEL3X                                  01815*90
         AIF   (N'&LABEL LE 4).LABEL4X                                  01816*90
.LABELRX AIF   ('&LABEL(4)' EQ '').LABEL4X                              01817*90
&C       SETC  '&LABEL(4)'                                              01818*90
&C       DC    Y(X'21',1,1)            LABEL=(,,, )                     01819*90
.LABEL4X AIF   ('&LABEL(3)' EQ '').LABEL3X                              01820*90
&C       SETC  '&LABEL(3)'                                              01821*90
&C       DC    Y(X'20',1,1)            LABEL=(,, )                      01822*90
.LABEL3X AIF   ('&LABEL(2)' EQ '').LABEL2X                              01823*90
&C       SETC  '&LABEL(2)'                                              01824*90
&C       DC    Y(X'1E',1,1)            LABEL=(, )                       01825*90
.LABEL2X AIF   ('&LABEL(1)' EQ '').LABELX                               01826*90
&C       SETC  '&LABEL(1)'                                              01827*90
&C       DC    Y(X'1F',1,2)            LABEL=( )                        01828*90
.LABELX  AIF   ('&PROTECT' EQ '').PROTECX                               01829*92
&PROTECT DC    Y(X'61',0)              PROTECT=YES                      01830*92
.PROTECX ANOP                                                           01831*92
.DDD2X   AIF   ('&DUMMY&DCB&SUBSYS' EQ '').DDD3X                        01832*92
         AIF   ('&DUMMY' EQ '').DUMMYX                                  01833*90
&DUMMY   DC    Y(X'24',0)              DUMMY                            01834*90
.DUMMYX  AIF   ('&DCB' EQ '').DCBX                                      01835*90
&A       SETA  N'&DCB+1                                                 01836*90
.DCBLOOP AIF   (&A LE 1).DCBX                                           01837*90
&A       SETA  &A-1                                                     01838*90
&C       SETC  '&DCB(&A)'                                               01839*90
         AIF   (K'&C LE 5).DCB4                                         01840*90
         AIF   ('&C'(1,8) NE 'BLKSIZE=').BLKSIZX                        01841*90
&C       SETC  '&C'(9,K'&C-8)                                           01842*90
&C       DC    Y(X'30',1,2)            DCB=BLKSIZE=                     01843*92
         AGO   .DCBLOOP                                                 01844*90
.BLKSIZX AIF   ('&C'(6,1) NE '=').DCB7                                  01845*90
&D       SETC  '&C'(7,K'&C-6)                                           01846*90
&C       SETC  '&C'(1,5)                                                01847*90
         AIF   ('&C' NE 'BUFNO').BUFNOX                                 01848*90
&D       DC    Y(X'34',1,1)            DCB=BUFNO=                       01849*90
         AGO   .DCBLOOP                                                 01850*90
.BUFNOX  AIF   ('&C' NE 'RECFM').RECFMX                                 01851*90
&D       DC    Y(X'49',1,1)            DCB=RECFM=                       01852*90
         AGO   .DCBLOOP                                                 01853*90
.RECFMX  AIF   ('&C' NE 'LRECL').LRECLX                                 01854*90
&D       DC    Y(X'42',1,2)            DCB=LRECL=                       01855*90
         AGO   .DCBLOOP                                                 01856*90
.LRECLX  AIF   ('&C' NE 'DSORG').DSORGX                                 01857*90
&D       DC    Y(X'3C',1,2)            DCB=DSORG=                       01858*92
         AGO   .DCBLOOP                                                 01859*90
.DSORGX  AIF   ('&C' NE 'EROPT').EROPTX                                 01860*90
&D       DC    Y(X'3D',1,1)            DCB=EROPT=                       01861*90
         AGO   .DCBLOOP                                                 01862*90
.EROPTX  AIF   ('&C' NE 'LIMCT').ERRDCB                                 01863*90
&D       DC    Y(X'41',1,3)            DCB=LIMCT=                       01864*90
         AGO   .DCBLOOP                                                 01865*90
.DCB7    AIF   ('&C'(1,7) NE 'KEYLEN=').DCB5                            01866*90
&C       SETC  '&C'(8,K'&C-7)                                           01867*90
&C       DC    Y(X'40',1,1)            DCB=KEYLEN=                      01868*90
         AGO   .DCBLOOP                                                 01869*90
.DCB5    AIF   ('&C'(1,5) NE 'BUFL=').DCB4                              01870*90
&C       SETC  '&C'(6,K'&C-5)                                           01871*90
&C       DC    Y(X'32',1,2)            DCB=BUFL=                        01872*90
         AGO   .DCBLOOP                                                 01873*90
.DCB4    AIF   ('&C'(4,1) NE '=').DCBREF                                01874*90
&D       SETC  '&C'(5,K'&C-4)                                           01875*90
&C       SETC  '&C'(1,3)                                                01876*90
         AIF   ('&C' NE 'DEN').DCBDENX                                  01877*90
&D       DC    Y(X'3B',1,1)            DCB=DEN=                         01878*90
         AGO   .DCBLOOP                                                 01879*90
.DCBDENX AIF   ('&C' NE 'NCP').ERRDCB                                   01880*90
&D       DC    Y(X'44',1,1)            DCB=NCP=                         01881*90
         AGO   .DCBLOOP                                                 01882*90
.DCBREF  AIF   (&A NE 1).ERRDCB2  POSITIONAL PARAMETER                  01883*90
         AIF   ('&C'(1,2) NE '*.').REFDSN                               01884*90
&C       SETC  '&C'(3,K'&C-2)                                           01885*90
&C       DC    Y(X'2D',1,8)            DCB=*. DDNAME REFERENCE          01886*90
         AGO   .DCBLOOP                                                 01887*90
.REFDSN  MNOTE 0,'DATASET REFERENCE ASSUMED IN DCB=&C'                  01888*90
&C       DC    Y(X'2C',1,44)           DCB= DSNAME REFERENCE            01889*90
         AGO   .DCBLOOP                                                 01890*90
.DCBX    AIF   ('&SUBSYS' EQ '').SUBSYSX                                01891*92
&C       SETC  '&SUBSYS(1)'                                             01892*92
         AIF   ('&C' EQ '').SUB1X                                       01893*92
&C       DC    Y(X'5F',1,4)            SUBSYS=( )                       01894*92
.SUB1X   AIF   ('&SUBSYS(2)' EQ '').SUBSYSX                             01895*92
&C       SETC  '&SUBSYS(2)'                                             01896*92
&C       DC    Y(X'60',1,256)          SUBSYS=(, )                      01897*92
.SUBSYSX ANOP                                                           01898*92
.DDD3X   AIF   ('&SYSOUT&DEST&HOLD&COPIES&OUTLIM&FCB&UCS' EQ '').DDD4X  01899*90
         AIF   ('&SYSOUT' EQ '').SYSOUTX                                01900*90
         AIF   ('&SYSOUT(1)' EQ '').SYSOU1X                             01901*90
&C       SETC  '&SYSOUT(1)'                                             01902*90
&C       DC    Y(X'18',1,1)            SYSOUT=( )                       01903*90
.SYSOU1X AIF   (N'&SYSOUT LE 1).SYSOUTX                                 01904*90
&C       SETC  '&SYSOUT(2)'                                             01905*90
         AIF   ('&C' EQ '').SYSOU2X                                     01906*90
&C       DC    Y(X'19',1,8)            SYSOUT=(, )                      01907*90
.SYSOU2X AIF   ('&SYSOUT(3)' EQ '').SYSOUTX                             01908*90
&C       SETC  '&SYSOUT(3)'                                             01909*90
&C       DC    Y(X'1A',1,4)            SYSOUT=(,, )                     01910*90
.SYSOUTX AIF   ('&DEST' EQ '').DESTX                                    01911*90
&DEST    DC    Y(X'58',1,7)            DEST=                            01912*92
.DESTX   AIF   ('&HOLD' EQ '').HOLDX                                    01913*90
&HOLD    DC    Y(X'59',0)              HOLD=YES                         01914*90
.HOLDX   AIF   ('&COPIES' EQ '').COPIESX                                01915*90
&COPIES  DC    Y(X'1D',1,1)            COPIES=                          01916*90
.COPIESX AIF   ('&OUTLIM' EQ '').OUTLIMX                                01917*90
&OUTLIM  DC    Y(X'1B',1,3)            OUTLIM=                          01918*90
.OUTLIMX AIF   ('&FCB' EQ '').FCBX                                      01919*90
         AIF   ('&FCB(1)' EQ '').FCB1X                                  01920*90
&FCB(1)  DC    Y(X'25',1,4)            FCB=( )                          01921*90
.FCB1X   AIF   ('&FCB(2)' EQ '').FCBX                                   01922*90
&FCB(2)  DC    Y(X'26',1,1)            FCB=(, )                         01923*90
.FCBX    AIF   ('&UCS' EQ '').UCSX                                      01924*90
         AIF   ('&UCS(1)' EQ '').UCS1X                                  01925*90
&UCS(1)  DC    Y(X'29',1,4)            UCS=( )                          01926*90
.UCS1X   AIF   ('&UCS(2)' EQ '').UCS2X                                  01927*90
&UCS(2)  DC    Y(X'2A',0)              UCS=(,FOLD)                      01928*90
.UCS2X   AIF   ('&UCS(3)' EQ '').UCSX                                   01929*90
&UCS(3)  DC    Y(X'2B',0)              UCS=(,,VERIFY)                   01930*90
.UCSX    ANOP                                                           01931*90
.DDD4X   AIF   ('&PASWORD' EQ '').PASWORX                               01932*90
&PASWORD DC    Y(X'50',1,8)            PASWORD=                         01933*90
.PASWORX MEXIT                                                          01934*90
.ERRDSN  MNOTE 12,'BOTH DSN= AND DSNAME= SPECIFIED. BOTH IGNORED.'      01935*90
         AGO   .DSNAMEX                                                 01936*90
.ERRMEM  MNOTE 12,'INVALID DSNAME, &C'                                  01937*90
         AGO   .DSNAMEX                                                 01938*90
.ERRSPA2 MNOTE 8,'TOO MAY SUBPARAMETERS IN SECOND SPACE PARAMETER, &C'  01939*90
         AGO   .SPACE2X                                                 01940*90
.ERRDCB2 MNOTE 8,'INVALID DCB PARAMETER, &C.. IGNORING.'                01941*90
         AGO   .DCBLOOP                                                 01942*90
.ERRDCB  MNOTE 8,'INVALID DCB PARAMETER, &C=&D.. IGNORED.'              01943*90
         AGO   .DCBLOOP                                                 01944*90
         MEND                                                           01945
./ ADD NAME=DYNALC   0100-03065-03065-2223-00549-00549-00000-DYNALLC
***********************************************************************
*        USAGE -THIS MACRO MADE BE USED  MULTIPLE TIMES IN ONE        *
*              PROGRAM AND GENERATE UNIQUE LABELS VIA THE 'SUFFIX'    *
*              PARAMETER.  PRIOR TO ISSUING SVC 99 REGISTER 1 MUST    *
*              CONTAIN THE ADDRESS OF   THIS PARAMETER LIST.          *
*              EX. -      PARMLIB   DYNALC DSNAME=SYS1.PARMLIB        *
*                                   ... ANY OTHER CODE                *
*                                   LA  R1,PARMLIB                    *
*                                   SVC 99                            *
*                                   ... ANY OTHER CODE                *
*        DEFAULTS -THERE ARE NO DEFAULTS FOR ANY PARM.  THE ONLY      *
*              PARMETERS THAT WILL BE GENERATED FOR DYNAMIC           *
*              ALLOCATION ARE THE ONES THAT ARE SPECIFICALLY CODED.   *
*              THE TYPE OF CALL TO DYNAMIC ALLOCATION DEFAULTS TO     *
*              ALLOCATION.  BY CODING IN A VALUE FOR DEALLOC, THE     *
*              PARAMETERS WILL DEALLOCATE THE RESOURCE INSTEAD OF     *
*              ALLOCATING IT.                                         *
*                                                                     *
*        LABELS - LABELS HAVE BEEN PROVIDED FOR OFTEN USED FIELDS.    *
*              FOR SVC 99 RB POINTER, THE LABELS GENERATED ARE THE    *
*              IEFZB4D0 MACRO LABEL MINUS THE S99 PREFIX AND SUFFIXED *
*              BY A UNIQUE 3 BYTE VALUE (AUTOMATICALLY SUPPLIED OR AS *
*              SPECIFIED BY 'SUFFIX=XXX'.  FOR EACH TEXT UNIT FIELD,  *
*              THE LABELS GENERATED ARE THE IEFZB4D2 MACRO LABEL      *
*              MINUS THE DAL PREFIX AND SUFFIXED AS SPECIFIED ABOVE.  *
***********************************************************************
         MACRO
&NAME    DYNALC                                                        X
               &DSNAME=,       DATASET NAME               (1-44 BYTES) X
               &DDNAME=,       DDNAME                      (1-8 BYTES) X
               &MEMBER=,       MEMBER NAME/GDG NUMBER        "    "    X
               &STATUS=,       DATASET STATUS        (OLD/MOD/NEW/SHR) X
               &NDISP=,        DATASET NORMAL DISP   (KEEP/DELETE/ETC) X
               &CDISP=,        DATASET COND. DISP      "     "     "   X
               &TYPSP=,        TYPE SPACE            (CYL/TRK/BLKSIZE) X
               &PRIME=,        PRIMARY SPACE REQUIREMENT (ANY NUMERIC) X
               &SECND=,        SECONDARY SPACE REQUIREMENT      "      X
               &DIR=,          DIRECTORY BLOCKS OR INDEX SPACE  "      X
               &RLSE=,         RELEASE UNUSED SPACE        (ANY VALUE) X
               &SPFRM=,        SPACE FORM            (ALX/MXIG/CONTIG) X
               &ROUND=,        ROUND BLOCKS TO CYLINDERS   (ANY VALUE) X
               &VOLSER=,       VOLUME SERIAL               (1-6 BYTES) X
               &VOLCNT=,       VOLUME COUNT                    (1-255) X
               &UNIT=,         UNIT TYPE                   (1-8 BYTES) X
               &MSVGP=,        MSVGP GROUP                   "    "    X
               &SYSOUT=,       SYSOUT CLASS              (A-Z/0-9/ETC) X
               &SPGNM=,        SYSOUT PGM NAME             (1-8 BYTES) X
               &FORM=,         SYSOUT FORM NAME              "    "    X
               &OUTLIM=,       SYSOUT OUTPUT LIMIT       (ANY NUMERIC) X
               &FREE=,         FREE AT CLOSE                   (CLOSE) X
               &COPIES=,       SYSOUT NUMBER OF COPIES         (1-255) X
               &LABEL=,        LABEL TYPE           (SL/NL/AL/BLP/ETC) X
               &DSSEQ=,        DATASET SEQUENCE NUMBER   (TAPE FILE #) X
               &PASPR=,        PASSWORD PROTECTION               (R/W) X
               &EXPDT=,        EXPIRATION DATE                 (YYDDD) X
               &RETPD=,        RETENTION PERIOD          (ANY NUMERIC) X
               &DUMMY=,        DUMMY DATASET               (ANY VALUE) X
               &DCBDS=,        DSNAME OF MODEL DSCB           (DSNAME) X
               &DCBDD=,        DDNAME OF MODEL DSCB           (DDNAME) X
               &BLKSIZE=,      BLOCKSIZE                 (ANY NUMERIC) X
               &DEN=,          TAPE DENSITY                  (1/2/3/4) X
               &DSORG=,        DATASET ORG.         (PO/PS/DA/POU/ETC) X
               &EROPT=,        ERROR OPTIONS             (ABE/SKP/ACC) X
               &KEYLEN=,       KEY LENGTH                (ANY NUMERIC) X
               &LRECL=,        LOGICAL RECORD LENGTH          "        X
               &OPTCD=,        OPTION CODE                   (B/W/C/Z) X
               &RECFM=,        RECORD FORMAT       (F/FB/VB/VBA/U/ETC) X
               &PASSWRD=,      PASSWORD                    (1-8 BYTES) X
               &PERM=,         PERM ALLOC                  (ANY VALUE) X
               &RETDD=,        RETURN DDNAME                    "      X
               &RETDS=,        RETURN DSNAME                    "      X
               &RETVOL=,       RETURN VOLSER                    "      X
               &FUNC=,         FOR PUNCH OUTPUT INTERPRETING       (I) X
               &SUFFIX=,       UNIQUE SUFFIX FOR LABELS    (MAX LEN=3) X
               &DEALLOC=       FOR DEALLOCATION            (ANY VALUE)
         LCLA  &A1,&A2,&A3
         LCLC  &X,&NM
         AIF   (T'&SUFFIX EQ 'O').SETSFX
         AIF   (K'&SUFFIX GT 3).SFXERR
&X       SETC  '&SUFFIX'
         AGO   .CONT
.SFXERR  MNOTE 8,'SUFFIX=&SUFFIX LONGER THAN 3 BYTES, FIRST THREE USED'
&X       SETC  '&SUFFIX'(1,3)
         AGO   .CONT
.SETSFX  ANOP
&X       SETC  '&SYSNDX'(2,3)
.CONT    ANOP
         AIF   (T'&NAME NE 'O').SETRB
         MNOTE 8,'REQUIRED LABEL MISSING ON MACRO CALL'
.SETRB   ANOP
&NAME    DC    A(DYNRB&X+X'80000000') POINTER TO REQUEST BLOCK
         AIF   (T'&DEALLOC EQ 'O').ALOCCHK
DYNRB&X  DC    AL1(20,2,0,0)       LENGTH, DEALLOC VERB, FLAGS1
         AGO   .ERINCHK
.ALOCCHK ANOP
DYNRB&X  DC    AL1(20,1,0,0)       LENGTH, ALLOC VERB, FLAGS1
.ERINCHK ANOP
ERROR&X  DC    AL2(0)              ERROR CODE
INFO&X   DC    AL2(0)              INFORMATION CODE
TUPTR&X  DC    A(TXTPP&X),AL4(0,0) TEXT UNIT POINTER, RSVD, FLAGS2
&A1      SETA  1
         AIF   (T'&DDNAME EQ 'O').DSNCHK
         AIF   (K'&DDNAME GT 8).DDNERR
TS&X&A1  DC    XL2'01',AL2(1,8)    DDNAME KEY, NUM, PARMLEN
DDNAM&X  DC    CL8'&DDNAME'        DDNAME FIELD
&A1      SETA  &A1+1
         AGO   .DSNCHK
.DDNERR  MNOTE 8,'DDNAME=&DDNAME GREATER THAN 8 BYTES'
.DSNCHK  AIF   (T'&DSNAME EQ 'O').MEMCHK
         AIF   (K'&DSNAME GT 44).DSNERR
TS&X&A1  DC    XL2'02',AL2(1,44)   DSNAME KEY, NUM, PARMLEN
DSNAM&X  DC    CL44'&DSNAME'       DSNAME FIELD
&A1      SETA  &A1+1
         AGO   .MEMCHK
.DSNERR  MNOTE 8,'DSNAME=&DSNAME GREATER THAN 44 BYTES'
.MEMCHK  AIF   (T'&MEMBER EQ 'O').STATCHK
         AIF   (K'&MEMBER GT 8).MEMERR
TS&X&A1  DC    XL2'03',AL2(1,8)    MEMBER/GDG KEY, NUM, PARMLEN
MEMBR&X  DC    CL8'&MEMBER'        MEMBER NAME/GDG LEVEL FIELD
&A1      SETA  &A1+1
         AGO   .STATCHK
.MEMERR  MNOTE 8,'MEMBER=&MEMBER GREATER THAN 8 BYTES'
.STATCHK AIF   (T'&STATUS EQ 'O').NDSPCHK
TS&X&A1  DC    XL2'04',AL2(1,1)    DATASET STATUS KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&STATUS' NE 'OLD').STA1CHK  OLD = X'01'
STATS&X  DC    XL1'01'             CONSTANT FOR DISP=OLD
         AGO   .NDSPCHK
.STA1CHK AIF   ('&STATUS' NE 'MOD').STA2CHK  MOD = X'02'
STATS&X  DC    XL1'02'             CONSTANT FOR DISP=MOD
         AGO   .NDSPCHK
.STA2CHK AIF   ('&STATUS' NE 'NEW').STA3CHK  NEW = X'04'
STATS&X  DC    XL1'04'             CONSTANT FOR DISP=NEW
         AGO   .NDSPCHK
.STA3CHK AIF   ('&STATUS' NE 'SHR').STAERR   SHR = X'08'
STATS&X  DC    XL1'08'             CONSTANT FOR DISP=SHR
         AGO   .NDSPCHK
.STAERR  MNOTE 8,'STATUS=&STATUS INVALID'
.NDSPCHK AIF   (T'&NDISP EQ 'O').CDSPCHK
TS&X&A1  DC    XL2'05',AL2(1,1)    NORMAL DISP KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&NDISP' NE 'UNCATLG').NDS1CHK UNCATLG = X'01'
NDISP&X  DC    XL1'01'             CONSTANT FOR NORMAL DISP=UNCATLG
         AGO   .CDSPCHK
.NDS1CHK AIF   ('&NDISP' NE 'CATLG').NDS2CHK CATLG   = X'02'
NDISP&X  DC    XL1'02'             CONSTANT FOR NORMAL DISP=CATLG
         AGO   .CDSPCHK
.NDS2CHK AIF   ('&NDISP' NE 'DELETE').NDS3CHK DELETE = X'04'
NDISP&X  DC    XL1'04'             CONSTANT FOR NORMAL DISP=DELETE
         AGO   .CDSPCHK
.NDS3CHK AIF   ('&NDISP' NE 'KEEP').NDSERR   KEEP    = X'08'
NDISP&X  DC    XL1'08'             CONSTANT FOR NORMAL DISP=KEEP
         AGO   .CDSPCHK
.NDSERR  MNOTE 8,'NDISP=&NDISP INVALID'
.CDSPCHK AIF   (T'&CDISP EQ 'O').TSPCCHK
TS&X&A1  DC    XL2'06',AL2(1,1)    COND DISP KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&CDISP' NE 'UNCATLG').CDS1CHK UNCATLG = X'01'
CDISP&X  DC    XL1'01'             CONSTANT FOR COND DISP=UNCALTG
         AGO   .TSPCCHK
.CDS1CHK AIF   ('&CDISP' NE 'CATLG').CDS2CHK   CATLG   = X'02'
CDISP&X  DC    XL1'02'             CONSTANT FOR COND DISP=CATLG
         AGO   .TSPCCHK
.CDS2CHK AIF   ('&CDISP' NE 'DELETE').CDS3CHK  DELETE  = X'04'
CDISP&X  DC    XL1'04'             CONSTANT FOR COND DISP=DELETE
         AGO   .TSPCCHK
.CDS3CHK AIF   ('&CDISP' NE 'KEEP').CDSERR     KEEP    = X'08'
CDISP&X  DC    XL1'08'             CONSTANT FOR COND DISP=KEEP
         AGO   .TSPCCHK
.CDSERR  MNOTE 8,'CDISP=&CDISP INVALID'
.TSPCCHK AIF   (T'&TYPSP EQ 'O').PSPCCHK
         AIF   ('&TYPSP' NE 'TRK').TSP1CHK  IF TYPE SPACE SPECIFICATION
TS&X&A1  DC    XL2'07',AL2(0)      TRACK SPACE KEY, NUM
&A1      SETA  &A1+1
         AGO   .PSPCCHK
.TSP1CHK AIF   ('&TYPSP' NE 'CYL').TSP2CHK  NOT TRK OR CYL THEN
TS&X&A1  DC    XL2'08',AL2(0)      CYLINDER SPACE KEY, NUM
&A1      SETA  &A1+1
         AGO   .PSPCCHK
.TSP2CHK AIF   (T'&TYPSP NE 'N').TYPERR
&A3      SETA  &TYPSP
         AIF   (&A3 GT 32768).TYPERR
TS&X&A1  DC    XL2'09',AL2(1,3)    BLOCK SPACE KEY, NUM, PARMLEN
BLKLN&X  DC    AL3(&TYPSP)         AVG BLOCK LENGTH FIELD
&A1      SETA  &A1+1
         AGO   .PSPCCHK
.TYPERR  MNOTE 8,'TYPSP=&TYPSP INVALID OR GREATER THAN 32768'
.PSPCCHK AIF   (T'&PRIME EQ 'O').DIRCCHK
         AIF   (T'&PRIME NE 'N').PSPCERR
TS&X&A1  DC    XL2'0A',AL2(1,3)    PRIME SPACE KEY, NUM, PARMLEN
PRIME&X  DC    AL3(&PRIME)         PRIMARY SPACE FIELD
&A1      SETA  &A1+1
         AGO   .SSPCCHK
.PSPCERR MNOTE 8,'PRIME=&PRIME INVALID'
.SSPCCHK AIF   (T'&SECND EQ 'O').DIRCCHK
         AIF   (T'&SECND NE 'N').SSPCERR
TS&X&A1  DC    XL2'0B',AL2(1,3)    SECONDARY SPACE, NUM, PARMLEN
SECND&X  DC    AL3(&SECND)         SECONDARY SPACE FIELD
&A1      SETA  &A1+1
         AGO   .DIRCCHK
.SSPCERR MNOTE 8,'SECND=&SECND INVALID'
.DIRCCHK AIF   (T'&DIR EQ 'O').RLSECHK
         AIF   (T'&DIR NE 'N').DIRCERR
TS&X&A1  DC    XL2'0C',AL2(1,3)    DIR SPACE KEY, NUM, PARMLEN
DIR&X    DC    AL3(&DIR)           DIR SPACE FIELD
&A1      SETA  &A1+1
         AGO   .RLSECHK
.DIRCERR MNOTE 8,'DIR=&DIR INVALID'
.RLSECHK AIF   (T'&RLSE EQ 'O').FMSPCHK
TS&X&A1  DC    XL2'0D',AL2(0)      RELEASE SPACE KEY, NUM
&A1      SETA  &A1+1
.FMSPCHK AIF   (T'&SPFRM EQ 'O').RNDCHK
TS&X&A1  DC    XL2'0E',AL2(1,1)    SPACE FORM KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&SPFRM' NE 'ALX').FMS1CHK
SPFRM&X  DC    XL1'02'             ALX SPACE FORM FIELD
         AGO   .RNDCHK
.FMS1CHK AIF   ('&SPFRM' NE 'MXIG').FMS2CHK
SPFRM&X  DC    XL1'04'             MXIG SPACE FORM FIELD
         AGO   .RNDCHK
.FMS2CHK AIF   ('&SPFRM' NE 'CONTIG').FMSERR
SPFRM&X  DC    XL1'02'             CONTIG SPACE FORM FIELD
         AGO   .RNDCHK
.FMSERR  ANOP
         MNOTE 8,'SPFRM=&SPFRM INVALID'
.RNDCHK  AIF   (T'&ROUND EQ 'O').VSERCHK
TS&X&A1  DC    XL2'0F',AL2(0)      ROUND KEY, NUM
&A1      SETA  &A1+1
.VSERCHK AIF   (T'&VOLSER EQ 'O').VLCNCHK
         AIF   (K'&VOLSER GT 6).VLSRERR
TS&X&A1  DC    XL2'10',AL2(1,6)    VOLSER KEY, NUM, PARMLEN
VLSER&X  DC    CL6'&VOLSER'        VOLUME SERIAL FIELD
&A1      SETA  &A1+1
         AGO   .VLCNCHK
.VLSRERR MNOTE 8,'VOLSER=&VOLSER GREATER THAN 6 BYTES'
.VLCNCHK AIF   (T'&VOLCNT EQ 'O').UNITCHK
         AIF   (T'&VOLCNT NE 'N').VLCERR
&A3      SETA  &VOLCNT
         AIF   (&A3 GT 255).VLCERR
TS&X&A1  DC    XL2'13',AL2(1,1)    VOLUME COUNT KEY, NUM, PARMLEN
VLCNT&X  DC    AL1(&VOLCNT)        VOLUME COUNT FIELD
&A1      SETA  &A1+1
         AGO   .UNITCHK
.VLCERR  MNOTE 8,'VOLCNT=&VOLCNT IS INVALID OR GREATER THAN 255'
.UNITCHK AIF   (T'&UNIT EQ 'O').SCLSCHK
TS&X&A1  DC    XL2'15',AL2(1,8)    UNIT TYPE KEY, NUM, PARMLEN
UNIT&X   DC    CL8'&UNIT'          UNIT TYPE FIELD
&A1      SETA  &A1+1
.SCLSCHK AIF   (T'&SYSOUT EQ 'O').SYSPCHK
TS&X&A1  DC    XL2'18',AL2(1,1)    SYSOUT CLASS KEY, NUM, PARMLEN
SYSOU&X  DC    CL1'&SYSOUT'        SYSOUT CLASS FIELD
&A1      SETA  &A1+1
.SYSPCHK AIF   (T'&SPGNM EQ 'O').FORMCHK
         AIF   (K'&SPGNM GT 8).SYSPERR
TS&X&A1  DC    XL2'19',AL2(1,8)    SYSOUT PGM KEY, NUM, PARMLEN
SPGNM&X  DC    CL8'&SPGNM'         SYSOUT PGM FIELD
&A1      SETA  &A1+1
         AGO   .FORMCHK
.SYSPERR MNOTE 8,'SPGNM=&SPGNM IS GREATER THAN 8 BYTES'
.FORMCHK AIF   (T'&FORM EQ 'O').OUTLCHK
         AIF   (K'&FORM GT 4).FORMERR
TS&X&A1  DC    XL2'1A',AL2(1,4)    SYSOUT FORM KEY, NUM, PARMLEN
FMNO&X   DC    CL4'&FORM'          SYSOUT FORM NUMBER FIELD
&A1      SETA  &A1+1
         AGO   .OUTLCHK
.FORMERR MNOTE 8,'FORM=&FORM IS GREATER THAN 4 BYTES'
.OUTLCHK AIF   (T'&OUTLIM EQ 'O').FREECHK
TS&X&A1  DC    XL2'1B',AL2(1,3)    OUTLIM KEY, NUM, PARMLEN
OUTLM&X  DC    AL3(&OUTLIM)        OUTLIM PGM FIELD
&A1      SETA  &A1+1
.FREECHK AIF   (T'&FREE EQ 'O').COPYCHK
         AIF   ('&FREE' NE 'CLOSE').FREERR
TS&X&A1  DC    XL2'1C',AL2(0)      FREE=CLOSE KEY, NUM
&A1      SETA  &A1+1               ALL ELSE WILL GENERATE MNOTE
         AGO   .COPYCHK
.FREERR  MNOTE 8,'FREE=&FREE INVALID'
.COPYCHK AIF   (T'&COPIES EQ 'O').LABLCHK
&A3      SETA  &COPIES
         AIF   (&A3 GT 255).COPYERR
TS&X&A1  DC    XL2'1D',AL2(1,1)    SYSOUT COPIES KEY, NUM, PARMLEN
COPYS&X  DC    AL1(&COPIES)        SYSOUT COPIES FIELD
&A1      SETA  &A1+1
         AGO   .LABLCHK
.COPYERR MNOTE 8,'COPIES=&COPIES GREATER THAN 255'
.LABLCHK AIF   (T'&LABEL EQ 'O').DSSQCHK
TS&X&A1  DC    XL2'1E',AL2(1,1)    LABEL TYPE KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&LABEL' NE 'NL').LAB1CHK NL  = X'01'
LABEL&X  DC    XL1'01'             LABEL = NL
         AGO   .DSSQCHK
.LAB1CHK AIF   ('&LABEL' NE 'SL').LAB2CHK SL  = X'02'
LABEL&X  DC    XL1'2'              LABEL = SL
         AGO   .DSSQCHK
.LAB2CHK AIF   ('&LABEL' NE 'NSL').LAB3CHK NSL = X'04'
LABEL&X  DC    XL1'04'             LABEL = NSL
         AGO   .DSSQCHK
.LAB3CHK AIF   ('&LABEL' NE 'SUL').LAB4CHK SUL = X'0A'
LABEL&X  DC    XL1'0A'             LABEL = SUL
         AGO   .DSSQCHK
.LAB4CHK AIF   ('&LABEL' NE 'BLP').LAB5CHK BLP = X'10'
LABEL&X  DC    XL1'10'             LABEL = BLP
         AGO   .DSSQCHK
.LAB5CHK AIF   ('&LABEL' NE 'LTM').LAB6CHK LTM = X'21'
LABEL&X  DC    XL1'21'             LABEL = LTM
         AGO   .DSSQCHK
.LAB6CHK AIF   ('&LABEL' NE 'AL').LAB7CHK AL  = X'40'
LABEL&X  DC    XL1'40'             LABEL = AL
         AGO   .DSSQCHK
.LAB7CHK AIF   ('&LABEL' NE 'AUL').LABERR  AUL = X'48'
LABEL&X  DC    XL1'48'             LABEL = AUL
         AGO   .DSSQCHK
.LABERR  MNOTE 8,'LABEL=&LABEL INVALID'
.DSSQCHK AIF   (T'&DSSEQ EQ 'O').PASSCHK
         AIF   (T'&DSSEQ NE 'N').DSSQERR
         AIF   (&DSSEQ GT 9999).DSSQERR
TS&X&A1  DC    XL2'1F',AL2(1,2)    DSN SEQUNECE KEY, NUM, PARMLEN
DSSEQ&X  DC    AL2(&DSSEQ)         DSN SEQUENCE FIELD
&A1      SETA  &A1+1
         AGO   .PASSCHK
.DSSQERR MNOTE 8,'DSSEQ=&DSSEQ INVALID OR OUT OF RANGE'
.PASSCHK AIF   (T'&PASPR EQ 'O').EXPDCHK
         AIF   ('&PASPR' NE 'R' AND 'PASPR' NE 'W').PASPERR
TS&X&A1  DC    XL2'20',AL2(1,1)    PASSWORD PROTECT KEY, NUM, PARMLEN
         AIF   ('&PASPR' EQ 'R').PASSRD
PASPR&X  DC    X'30'               WRITE PROTECTION
&A1      SETA  &A1+1
         AGO   .EXPDCHK
.PASSRD  ANOP
PASPR&X  DC    X'10'               READ/WRITE PROTECTION
&A1      SETA  &A1+1
         AGO   .EXPDCHK
.PASPERR MNOTE 8,'PASPR=&PASPR INVALID-SHOULD BE "R" OR "W"'
.EXPDCHK AIF   (T'&EXPDT EQ 'O').RETPCHK
         AIF   (K'&EXPDT GT 5).EXPDERR
TS&X&A1  DC    XL2'22',AL2(1,5)    EXPIRATION DATE KEY, NUM, PARMLEN
EXPDT&X  DC    CL5'&EXPDT'         EXPIRATION DATE FIELD
&A1      SETA  &A1+1
         AGO   .RETPCHK
.EXPDERR MNOTE 8,'EXPDT=&EXPDT GREATER THAN 5 BYTES'
.RETPCHK AIF   (T'&RETPD EQ 'O').DUMMCHK
         AIF   (T'&RETPD NE 'N').RETPERR
&A3      SETA  &RETPD
         AIF   (&RETPD GT 9999).RETPERR
TS&X&A1  DC    XL2'23',AL2(1,2)    RETENTION PERIOD KEY, NUM, PARMLEN
RETPD&X  DC    AL2(&RETPD)         RETENTION PERIOD FIELD
&A1      SETA  &A1+1
         AGO   .DUMMCHK
.RETPERR MNOTE 8,'RETPD=&RETPD NOT NUMERIC OR GREATER THAN 9999'
.DUMMCHK AIF   (T'&DUMMY EQ 'O').DCBSCHK
TS&X&A1  DC    XL2'24',AL2(0)      DUMMY DATASET KEY, NUM
&A1      SETA  &A1+1
.DCBSCHK AIF   (T'&DCBDS EQ 'O').DCBDCHK
         AIF   (K'&DCBDS GT 44).DCBSERR
TS&X&A1  DC    XL2'2C',AL2(1,44)   DCB REFERENCE DSN KEY, NUM, PARMLEN
DCBDS&X  DC    CL44'&DCBDS'        DCB REFERENCE DSNAME FIELD
&A1      SETA  &A1+1
         AGO   .DCBDCHK
.DCBSERR MNOTE 8,'DCBDS=&DCBDS GREATER THAN 44 BYTES'
.DCBDCHK AIF   (T'&DCBDD EQ 'O').BLKSCHK
         AIF   (K'&DCBDS GT 8).DCBDERR
TS&X&A1  DC    XL2'2D',AL2(1,8)    DCB REFERENCE DDN KEY, NUM, PARMLEN
DCBDS&X  DC    CL8'&DCBDD'         DCB REFERENCE DDNAME FIELD
&A1      SETA  &A1+1
         AGO   .BLKSCHK
.DCBDERR MNOTE 8,'DCBDD=&DCBDD GREATER THAN 8 BYTES'
.BLKSCHK AIF   (T'&BLKSIZE EQ 'O').DENSCHK
         AIF   (T'&BLKSIZE NE 'N').BLKSERR
&A3      SETA  &BLKSIZE
         AIF   (&A3 GT 32768).BLKSERR
TS&X&A1  DC    XL2'30',AL2(1,2)    BLOCKSIZE KEY, NUM, PARMLEN
BLKSZ&X  DC    AL2(&BLKSIZE)       BLOCKSIZE FIELD
&A1      SETA  &A1+1
         AGO   .DENSCHK
.BLKSERR MNOTE 8,'BLKSIZE=&BLKSIZE INVALID OR GREATER THAN 32768'
.DENSCHK AIF   (T'&DEN EQ 'O').DSORCHK
TS&X&A1  DC    XL2'3B',AL2(1,1)    DENSITY KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&DEN' NE '4').DEN1CHK DEN4 = X'D3'
DEN&X    DC    XL1'D3'             DEN = 4
         AGO   .DSORCHK
.DEN1CHK AIF   ('&DEN' NE '3').DEN2CHK DEN3 = X'C3'
DEN&X    DC    XL1'C3'             DEN = 3
         AGO   .DSORCHK
.DEN2CHK AIF   ('&DEN' NE '2').DEN3CHK DEN2 = X'83'
DEN&X    DC    XL1'83'             DEN = 2
         AGO   .DSORCHK
.DEN3CHK AIF   ('&DEN' NE '1').DENERR  DEN1 = X'43'
DEN&X    DC    XL1'43'             DEN = 1
         AGO   .DSORCHK
.DENERR  MNOTE 8,'DEN=&DEN INVALID'
.DSORCHK AIF   (T'&DSORG EQ 'O').EROPCHK
TS&X&A1  DC    XL2'3C',AL2(1,2)    DSORG KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&DSORG' NE 'PO').DSO1CHK DSORG PO = X'0200'
DSORG&X  DC    XL2'0200'           DSORG = PO
         AGO   .EROPCHK
.DSO1CHK AIF   ('&DSORG' NE 'PS').DSO2CHK DSORG PS = X'4000'
DSORG&X  DC    XL2'4000'           DSORG = PS
         AGO   .EROPCHK
.DSO2CHK AIF   ('&DSORG' NE 'DA').DSO3CHK DSORG DA = X'2000'
DSORG&X  DC    XL2'2000'           DSORG = DA
         AGO   .EROPCHK
.DSO3CHK AIF   ('&DSORG' NE 'VS').DSO4CHK DSORG VS = X'0008'
DSORG&X  DC    XL2'0008'           DSORG = VS
         AGO   .EROPCHK
.DSO4CHK AIF   ('&DSORG' NE 'POU').DSO5CHK DSORG POU = X'0300'
DSORG&X  DC    XL2'0300'           DSORG = POU
         AGO   .EROPCHK
.DSO5CHK AIF   ('&DSORG' NE 'PSU').DSO6CHK DSORG PSU = X'4100'
DSORG&X  DC    XL2'4100'           DSORG = PSU
         AGO   .EROPCHK
.DSO6CHK AIF   ('&DSORG' NE 'DAU').DSOERR  DSORG DAU = X'2100'
DSORG&X  DC    XL2'2100'           DSORG = DAU
         AGO   .EROPCHK
.DSOERR  MNOTE 8,'DSORG=&DSORG INVALID'
.EROPCHK AIF   (T'&EROPT EQ 'O').KEYLCHK
TS&X&A1  DC    XL2'3D',AL2(1,1)    EROPT KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&EROPT' NE 'ABE').ERO1CHK EROPT ABE = X'20'
EROPT&X  DC    XL1'20'             EROPT = ABE
         AGO   .KEYLCHK
.ERO1CHK AIF   ('&EROPT' NE 'SKP').ERO2CHK EROPT SKP = X'40'
EROPT&X  DC    XL1'40'             EROPT = SKP
         AGO   .KEYLCHK
.ERO2CHK AIF   ('&EROPT' NE 'ACC').EROERR  EROPT ACC = X'80'
EROPT&X  DC    XL1'80'             EROPT = ACC
         AGO   .KEYLCHK
.EROERR  MNOTE 8,'EROPT=&EROPT INVALID'
.KEYLCHK AIF   (T'&KEYLEN EQ 'O').LRECCHK
TS&X&A1  DC    XL2'40',AL2(1,1)    KEYLEN KEY, NUM, PARMLEN
KYLEN&X  DC    AL1(&KEYLEN)        KEYLEN FIELD
&A1      SETA  &A1+1
.LRECCHK AIF   (T'&LRECL EQ 'O').OPTCCHK
TS&X&A1  DC    XL2'42',AL2(1,2)    LRECL KEY, NUM, PARMLEN
LRECL&X  DC    AL2(&LRECL)         LRECL FIELD
&A1      SETA  &A1+1
.OPTCCHK AIF   (T'&OPTCD EQ 'O').RECFCHK
TS&X&A1  DC    XL2'45',AL2(1,1)    OPTCD KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&OPTCD' NE 'B').OPT1CHK OPTCD B = X'40'
OPTCD&X  DC    XL1'40'             OPTCD = B
         AGO   .RECFCHK
.OPT1CHK AIF   ('&OPTCD' NE 'W').OPT2CHK OPTCD W = X'80'
OPTCD&X  DC    XL1'80'             OPTCD = W
         AGO   .RECFCHK
.OPT2CHK AIF   ('&OPTCD' NE 'C').OPT3CHK OPTCD C = X'20'
OPTCD&X  DC    XL1'20'             OPTCD = C
         AGO   .RECFCHK
.OPT3CHK AIF   ('&OPTCD' NE 'Z').OPTERR  OPTCD Z = X'04'
OPTCD&X  DC    XL1'04'             OPTCD = Z
         AGO   .RECFCHK
.OPTERR  MNOTE 8,'OPTCD=&OPTCD INVALID'
.RECFCHK AIF   (T'&RECFM EQ 'O').PASWCHK
TS&X&A1  DC    XL2'49',AL2(1,1)    RECFM KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&RECFM' NE 'FBA').REC1CHK RECFM FBA = X'94'
RECFM&X  DC    XL1'94'             RECFM = FBA
         AGO   .PASWCHK
.REC1CHK AIF   ('&RECFM' NE 'VBA').REC2CHK RECFM VBA = X'54'
RECFM&X  DC    XL1'54'             RECFM = VBA
         AGO   .PASWCHK
.REC2CHK AIF   ('&RECFM' NE 'FB').REC3CHK RECFM FB = X'90'
RECFM&X  DC    XL1'90'             RECFM = FB
         AGO   .PASWCHK
.REC3CHK AIF   ('&RECFM' NE 'VB').REC4CHK RECFM VB = X'50'
RECFM&X  DC    XL1'50'             RECFM = VB
         AGO   .PASWCHK
.REC4CHK AIF   ('&RECFM' NE 'F').REC5CHK RECFM F = X'80'
RECFM&X  DC    XL1'80'             RECFM = F
         AGO   .PASWCHK
.REC5CHK AIF   ('&RECFM' NE 'V').REC6CHK RECFM V = X'40'
RECFM&X  DC    XL1'40'             RECFM = V
         AGO   .PASWCHK
.REC6CHK AIF   ('&RECFM' NE 'FBS').REC7CHK RECFM FBS = X'98'
RECFM&X  DC    XL1'98'             RECFM = FBS
         AGO   .PASWCHK
.REC7CHK AIF   ('&RECFM' NE 'VBS').REC8CHK RECFM VBS = X'58'
RECFM&X  DC    XL1'58'             RECFM = VBS
         AGO   .PASWCHK
.REC8CHK AIF   ('&RECFM' NE 'FA').REC9CHK RECFM FA = X'84'
RECFM&X  DC    XL1'84'             RECFM = FA
         AGO   .PASWCHK
.REC9CHK AIF   ('&RECFM' NE 'VA').RECACHK RECFM VA = X'44'
RECFM&X  DC    XL1'44'             RECFM = VA
         AGO   .PASWCHK
.RECACHK AIF   ('&RECFM' NE 'FBM').RECBCHK RECFM FBM = X'92'
RECFM&X  DC    XL1'92'             RECFM = FBM
         AGO   .PASWCHK
.RECBCHK AIF   ('&RECFM' NE 'VBM').RECCCHK RECFM VBM = X'52'
RECFM&X  DC    XL1'52'             RECFM = VBM
         AGO   .PASWCHK
.RECCCHK AIF   ('&RECFM' NE 'FBSA').RECDCHK RECFM FBSA = X'9C'
RECFM&X  DC    XL1'9C'             RECFM = FBSA
         AGO   .PASWCHK
.RECDCHK AIF   ('&RECFM' NE 'U').RECFERR RECFM U = X'C0'
RECFM&X  DC    XL1'C0'             RECFM = U
         AGO   .PASWCHK
.RECFERR MNOTE 8,'RECFM=&RECFM INVALID'
.PASWCHK AIF   (T'&PASSWRD EQ 'O').PERMCHK
         AIF   (K'&PASSWRD GT 8).PASWERR
TS&X&A1  DC    XL2'50',AL2(1,8)    PASSWORD KEY, NUM, PARMLEN
PASSW&X  DC    CL8'&PASSWRD'       PASSWORD
&A1      SETA  &A1+1
         AGO   .PERMCHK
.PASWERR MNOTE 8,'PASSWRD=&PASSWRD GREATER THAN 8 BYTES'
.PERMCHK AIF   (T'&PERM EQ 'O').RTDDCHK
TS&X&A1  DC    XL2'52',AL2(0)      PERM ALLOC KEY, NUM
&A1      SETA  &A1+1
.RTDDCHK AIF   (T'&RETDD EQ 'O').RTDSCHK
TS&X&A1  DC    XL2'55',AL2(1,8)    RETURN DDNAME, NUM, PARMLEN
RTDDN&X  DC    CL8' '              RETURNED DDNAME
&A1      SETA  &A1+1
.RTDSCHK AIF   (T'&RETDS EQ 'O').FUNCCHK
TS&X&A1  DC    XL2'56',AL2(1,44)   RETURN DSNAME, NUM, PARMLEN
RTDSN&X  DC    CL44' '             RETURNED DSNAME
&A1      SETA  &A1+1
.FUNCCHK AIF   (T'&FUNC EQ 'O').RTVLCHK
         AIF   ('&FUNC' NE 'I').FUNCERR
TS&X&A1  DC    XL2'5A',AL2(1,1)    FUNCTION KEY, NUM, PARMLEN
FUNC&X   DC    XL1'80'             INTERPRET FUNCTION FIELD
&A1      SETA  &A1+1
         AGO   .RTVLCHK
.FUNCERR MNOTE 8,'FUNC=&FUNC NOT SUPPORTED BY MACRO'
.RTVLCHK AIF   (T'&RETVOL EQ 'O').MSVGCHK
TS&X&A1  DC    XL2'5D',AL2(1,6)    RETURN VOLSER, NUM, PARMLEN
RTVOL&X  DC    CL6' '              RETURNED VOLSER
&A1      SETA  &A1+1
.MSVGCHK AIF   (T'&MSVGP EQ 'O').TUPLGEN
TS&X&A1  DC    XL2'5E',AL2(1,8)    MSVGP KEY, NUM, PARMLEN
MSVGP&X  DC    CL8'&MSVGP'         MSVGP FIELD
&A1      SETA  &A1+1
.TUPLGEN ANOP
&A2      SETA  1
&A1      SETA  &A1-1 BB
         AIF   (&A1 GE 1).GENOK BB
         MNOTE 8,'NO TEXT UNIT POINTERS WERE GENERATED' BB
         MEXIT BB
.GENOK   ANOP BB
&NM      SETC  'TXTPP&X'
.TULOOP  AIF   (&A2 EQ &A1).EOFGEN
&NM      DC    A(TS&X&A2)          TEXT UNIT POINTER
&NM      SETC  ' '
&A2      SETA  &A2+1
         AGO   .TULOOP
.EOFGEN  AIF   (&A1 NE 1).SKIPCLR
&NM      SETC  'TXTPP&X'
.SKIPCLR ANOP
&NM      DC    A(TS&X&A2+X'80000000') LAST TEXT UNIT POINTER
         MEND
./ ADD NAME=DYNSPACE 0100-03065-03065-2223-00052-00052-00000-DYNALLC
         MACRO
&NAME    DYNSPACE &TYPE
.*
.*    THIS IS AN INNER MACRO TO ALLOC/FREE.
.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST
.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY
.*                         EACH, REMEMBERING THE LARGEST.
.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.
.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,
.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,
.*    OR BY BEGINWKA, IF THE LATTER IS USED.
.*
.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE
.*     NAME DYNSPACE
.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE
.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL
.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.
.*
.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL
.*          DYNSPACE ADD
.*     (NO NAME FIELD AND ONE OPERAND)
.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE
.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE
.*     CURRENT REQUEST IS FOR A GREATER AMOUNT
.*
.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO
.*     NAME OR OPERAND FIELD.
.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME
.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.
.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.
.*
         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN
         GBLC  &DYNP,&DYNSP
         LCLA  &I
         AIF   ('&NAME' NE '').NAME
         AIF   ('&TYPE' EQ '').ALLOC
.*   THE ACCUMULATE FUNCTION IS REQUIRED
&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST
         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT
&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM
         MEXIT
.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT
&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME
.EXIT    MEXIT
.ALLOC   AIF   ('&DYNSP' EQ '').EXIT
*
**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA
*
&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE
&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0
&DYNSPQ  SETA 0
         MEND
./ ADD NAME=FREE     0100-03065-03065-2223-00133-00133-00000-DYNALLC
         MACRO
&NAME    FREE  &UNALC,&DSN=,&DDN=,&MEMBER=,&DISP=,&SYSOUT=,            X
               &ERROR=,&MF=AUTO,&PREFIX=,&FILE=,&F=,&DA=,&HOLD=
         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO
         GBLA  &DTUO              OFFSET TO TEXT UNITS
         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS
         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS
         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL
         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC
         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E
         LCLC  &C,&T,&PAR
&RCPS99(1)     SETB           1
&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER
&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX
&NAME    DS    0H
         AIF   ('&PREFIX' EQ '').TMF
         AIF   (K'&PREFIX LT 4).POK
         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'
&DYNP    SETC  '&PREFIX'(1,4)
         AGO   .TMF
.POK     ANOP
&DYNP    SETC  '&PREFIX'
.TMF     AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF' NE 'AUTO').TMFE
NAME     DYNSPACE             GET NAME FOR SPACE
         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST
         USING &DYNP.DS,R1             USE GENERATED DSECT
&T       SETC  'A'
&PAR     SETC  '&DYNSP+4'
&DSECT   SETB  1
         AGO   .START
.TMFE    AIF   ('&MF(2)' NE '').E2OK
         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'
         AGO   .GEN
.E2OK    ANOP
&DSECT   SETB  1
         AIF   ('&MF(2)' EQ '(').RMFE
         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS
&T       SETC  'A'
&PAR     SETC  '&MF(2)+4'
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START
&PAR     SETC  '&MF(2)'(2,K'&MF(2)-2)
&T       SETC  'R'
         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS
&PAR     SETC  '4&MF(2)'
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP
&T       SETC  'A'
&PAR     SETC  '&DYNP.RB'
.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB
         USING S99RB,R15
         ST    R15,0(R1)               AND STORE IN RB POINTER
         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST
         MVI   S99RBLN,20              MOVE IN LIST LENGTH
         MVI   S99VERB,S99VRBUN        MOVE IN VERB CODE
         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS
         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB
         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS
         USING S99TUNIT,R15
&DTUO    SETA  0
&DTUPO   SETA  0
         AIF   ('&DSN&DA' NE '').DSN
         AIF   ('&SYSOUT' NE '').SYSOUT
.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN
.TDISP   AIF   ('&DISP' NE '').DISP
.TUNALC  AIF   ('&UNALC' NE '').PERM
.THOLD   AIF   ('&HOLD' NE '').HOLD
         AGO   .SVC99
.DSN     RCPFDSN &DSN&DA,&MEMBER
         AGO   .TDDN
.SYSOUT  RCPFSYS &SYSOUT
         AGO   .TDDN
.DDN     RCPFDDN &DDN&F&FILE
         AGO   .TDISP
.DISP RCPFDISP &DISP
         AGO   .TUNALC
.PERM    RCPUNALC
         AGO   .THOLD
.HOLD    RCPFHOLD &HOLD
.SVC99   ANOP
&DTUPO   SETA  &DTUPO-4
         SPACE
         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS
         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR
         RCPSR2 UNSAVE
&DTUPO   SETA  &DTUPO+4
         AIF   (NOT &DSECT).DYNA
         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY
.DYNA    DYNALLOC
         AIF   ('&ERROR' EQ '').RESERVE
         AIF   ('&PAR' EQ '').LTR
         L&T   R14,&PAR                 LOAD REG 14 WITH ADDRESS OF RB
         AIF   (NOT &DSECT).LTR
         USING &DYNP.RB,R14            SET UP ADDRESSABILITY
.LTR     LTR   R15,R15                 TEST RETURN CODE
         BNZ   &ERROR                  BRANCH IF NON ZERO
**       NOTE.  R14 POINTS TO REQUEST BLOCK, R15 HAS RETURN CODE     **
.RESERVE AIF   (&DSECT).RESDS
         SPACE
***********************************************************************
**       RESERVE SPACE FOR DYNALLOC DATA                             **
***********************************************************************
         RCPDS
.SSP     ANOP
&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER
&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK
&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS
         AIF   (&DTUO EQ 0).DTU11
&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS
         AGO   .DTU10
.DTU11   ANOP
&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS
.DTU10   ANOP
&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED
         AIF   (&DSECT).DSP
         RCPDS
         SPACE 3
         AGO   .EXIT
.RESDS   ANOP
         AIF   ('&DYNSP' EQ '').SP3
         DYNSPACE ADD
.SP3     SPACE
&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA
         AGO   .SSP
.DSP     AIF   ('&MF(3)' EQ '').END1
&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA
.END1    ANOP
&SYSECT  CSECT
         SPACE 3
.EXIT    MEND
./ ADD NAME=FREEDD   0100-03065-03065-2223-00085-00085-00000-DYNALLC
         MACRO
&DDNAME  FREEDD &DSN=,&DSNAME=,&DISP=,&SYSOUT=,&DEST=,&HOLD=,          *
               &KEYADDS=,&TYPE=UNALLOC,&EXIT=ALODDERR
         GBLA  &X,&Y,&H,&N,&R
         GBLB  &CONCATB,&FREEB,&DDDFAIL,&DDDD
         LCLA  &A
         LCLC  &C,&D
         AIF   (&DDDD).ERRDDDD
         AIF   (&CONCATB).ERRCONC
&X       SETA  20 DISPLACEMENT FROM ALOBLOCK TO FIRST TEXT UNIT POINTER
&Y       SETA  20         NEGATIVE DISTANCE FROM ALOBLOCK TO FIRST DATA
&R       SETA  14                      FIRST REGISTER LOADED
&FREEB   SETB  1
         AIF   ('&DDNAME&DSN&DSNAME&DISP' EQ '').DDD5X
         AIF   ('&DDNAME' EQ 'RETURN').ERRRET
.DDNAMEX AIF   ('&DISP(1)' NE '').ERRDIS1
.DISP1X  AIF   ('&DISP(3)' NE '').ERRDIS3
.DISP3X  DDD5  &DDNAME,&DSN,&DSNAME,&DISP
.DDD5X   AIF   ('&SYSOUT&DEST&HOLD' EQ '').DDD4X
         AIF   (N'&SYSOUT GT 1).ERRSYSO
.SYSOUTX DDD4  &SYSOUT,&DEST,&HOLD
         AIF   ('&HOLD' NE 'NO').DDD4X
         DDD0  =Y(X'0A',0),,,,'HOLD=NO'
.DDD4X   AIF   ('&KEYADDS' EQ '').KEYADDX
&A       SETA  0
.KEYLOOP AIF   (&A GE N'&KEYADDS).KEYADDX
&A       SETA  &A+1
&C       SETC  '&KEYADDS(&A)'
         AIF   ('&C' EQ '').KEYLOOP
         AIF   ('&C'(1,1) EQ '(').KEYADDR
         DDD0  &C,,,,'KEYADDS=&C'
         AGO   .KEYLOOP
.KEYADDR DDD0  0&C,,,,'KEYADDS=&C'
         AGO   .KEYLOOP
.KEYADDX AIF   ('&TYPE' EQ 'EITHER' OR '&TYPE' EQ '').TYPEX
         AIF   ('&TYPE' NE 'UNALLOC').TYPER
.TYPEU   DDD0  =Y(X'07',0),,,,                                         *
               'TYPE=UNALLOC  EVEN IF PERMANENTLY ALLOCATED'
         AGO   .TYPEX
.TYPER   AIF   ('&TYPE' NE 'REMOVE').ERRTYPE
         DDD0  =Y(X'08',0),,,,'TYPE=REMOVE  IN-USE ATTRIBUTE'
.TYPEX   AIF   (&R NE 14).R14X
&X       SETA  &X-4
         AGO   .RX
.R14X    AIF   (&R NE 15).R15X
         ST    14,ALOBLOCK+&X
         AGO   .RX
.R15X    AIF   (&R NE 0).R0X
         STM   14,15,ALOBLOCK+&X
&X       SETA  &X+4
         AGO   .RX
.R0X     STM   14,0,ALOBLOCK+&X
&X       SETA  &X+8
.RX      OI    ALOBLOCK+&X,X'80'        SET END OF TEXT UNIT ADDR LIST
         LA    0,X'0220'               LOAD VERB, FLAGS1
         AIF   ('&EXIT'(1,1) EQ '(').LREXIT
&DDDFAIL SETB  ('&EXIT' EQ 'ALODDERR' OR &DDDFAIL)
         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
         AGO   .BALDDDD
.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS
.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO
         AIF   (&H GE &Y).HX
&H       SETA  &Y
.HX      AIF   (&N GE &X).NX
&N       SETA  &X
.NX      MEXIT
.ERRDDDD MNOTE 12,'FREEDD MAY NOT BE ISSUED AFTER DDDD'
         MEXIT
.ERRCONC MNOTE 12,'FREEDD MAY NOT BE ISSUED DURING CONCATENATION.'
         MEXIT
.ERRRET  MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT RETURN OF THE *
               DDNAME.'
         AGO   .DDNAMEX
.ERRDIS1 MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT DISP=(&DISP(1)*
               ).'
         AGO   .DISP1X
.ERRDIS3 MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT DISP=(,,&DISP(*
               3)).'
         AGO   .DISP3X
.ERRSYSO MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT SYSOUT=(,&SYSO*
               UT(2),&SYSOUT(3)).'
         AGO   .SYSOUTX
.ERRTYPE MNOTE 8,'TYPE=&TYPE INVALID. TYPE IGNORED.'
         AGO   .TYPEU
         MEND
./ ADD NAME=RCPBFRGS 0100-03065-03065-2223-00019-00019-00000-DYNALLC
         MACRO
         RCPBFRGS &BUFPTR,&WKREGS
         GBLC  &RCPBFRP,&RCPBFR1,&RCPBFR2
         AIF   ('&BUFPTR' EQ '').TGP
&RCPBFRP SETC  '&BUFPTR'
         AGO   .TWK1
.TGP     AIF   ('&RCPBFRP' NE '').TWK1
&RCPBFRP SETC  'R1'
.TWK1    AIF   ('&WKREGS(1)' EQ '').TG1
&RCPBFR1 SETC  '&WKREGS(1)'
         AGO   .TWK2
.TG1     AIF   ('&RCPBFR1' NE '').TWK2
&RCPBFR1 SETC  'R14'
.TWK2    AIF   ('&WKREGS(2)' EQ '').TG2
&RCPBFR2 SETC  '&WKREGS(2)'
         MEXIT
.TG2     AIF   ('&RCPBFR2' NE '').EXIT
&RCPBFR2 SETC  'R15'
.EXIT    MEND
./ ADD NAME=RCPBTU   0100-03065-03065-2223-00017-00017-00000-DYNALLC
         MACRO
         RCPBTU &KEY,&NUM,&PAR
         LCLA  &L
.*
.*  INNER MACRO FOR ALLOC, TO GENERATE TEXT UNITS ENTERED
.*  IN QUOTES
.*
&L       SETA  K'&PAR-2                GET LENGTH OF TEXT UNIT
         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY
         MVI   S99TUNUM+1,&NUM         SET NUMBER FIELD
         MVI   S99TULNG+1,&L           MOVE IN LENGTH
         MVC   S99TUPAR(&L.),=C&PAR    MOVE IN TEXT UNIT
&L       SETA  &L+6
         AIF   (&L/2 EQ (&L+1)/2).LOK
&L       SETA  &L+1
.LOK     RCPDINC &L
         MEND
./ ADD NAME=RCPBTU2  0100-03065-03065-2223-00019-00019-00000-DYNALLC
         MACRO
         RCPBTU &KEY,&NUM,&PAR
         GBLA  &DTUPO
         GBLC  &DYNP
         LCLA  &L
.*
.*  INNER MACRO FOR ALLOC, TO BRANCH AROUND TEXT UNIT AND
.*  CREATE TEXT UNIT
.*
&L       SETA  K'&PAR+8                GET LENGTH TO BRANCH AROUND
         AIF   (&L/2 EQ (&L+1)/2).LOK  MAKE SURE LENGTH IS EVEN
&L       SETA  &L+1
.LOK     BAL   R14,*+&L                BRANCH AROUND TEXT UNIT
&L       SETA  K'&PAR-2
         DC    Y(&KEY,&NUM,&L),C&PAR   TEXT UNIT
         LA    R14,0(R14)              CLEAR HIGH ORDER BYTE
         ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
&DTUPO   SETA  &DTUPO+4
         MEND
./ ADD NAME=RCPCKID  0100-03065-03065-2223-00045-00045-00000-DYNALLC
         MACRO
&NAME    RCPCKID              &CHECKID
         GBLB  &RCPECT(2),&RCPPSCB(2)
         GBLC  &RCPPRE
         LCLC  &CHARVAR,&P
         LCLA  &COUNTR,&L
&P       SETC  '&RCPPRE'
&RCPPSCB(1) SETB  1
&RCPECT(1)  SETB  1
         EJECT
         SPACE 4
***********************************************************************
***  THE USERID OF THE USER IS CHECKED. IF IT IS NOT VALID, THE    ****
***   COMMAND PRETENDS IT DOES NOT EXIST BY LINKING TO EXEC IN     ****
***   THE SAME WAY THE TMP DOES IF IT CANNOT FIND THE COMMAND.     ****
***********************************************************************
         SPACE 3
         L     R1,CPPLPSCB             LOAD ADDRESS OF PSCB
         USING PSCB,R1                 PSCB ADDRESSABILITY
.NID     ANOP
&COUNTR  SETA  &COUNTR+1
         AIF   ('&CHECKID(&COUNTR)' EQ '').ENDID
&CHARVAR SETC  '&CHECKID(&COUNTR)'
&L       SETA  K'&CHARVAR
         AIF   ('&CHARVAR'(1,1) EQ '''').QCID
         CLC   PSCBUSER(&L),=C'&CHARVAR'  IS THE USERID VALID?
         BE    &P.IDOK                     YES, BRANCH OUT
         AGO   .NID
.QCID    ANOP
&L       SETA  &L-2
         CLC   PSCBUSER(&L),=C&CHARVAR    IS THE USERID VALID?
         BE    &P.IDOK                     YES, BRANCH OUT
         AGO   .NID
.ENDID   L     R1,CPPLECT              LOAD ECT ADDRESS
         SPACE 2
         USING ECT,R1
         MVC   ECTPCMD,&P.EXECN        MOVE IN COMMAND NAME
         DROP  R1                      KILL ECT ADDRESSABILITY
         L     R1,CPPLCBUF             LOAD CBUF ADDRESS
         XC    2(2,R1),2(R1)           ZERO OFFSET FIELD
         L     R1,&P.CPPL              RELOAD CPPL ADDRESS
         XCTL  EPLOC=&P.EXECN
&P.EXECN DC    CL8'EXEC'               NAME OF EXEC PROCESSOR
&P.IDOK  DS    0H
         MEND
./ ADD NAME=RCPDDCB  0100-03065-03065-2223-00164-00164-00000-DYNALLC
         MACRO
         RCPDDCB &LRECL=,&BLKSIZE=,&RECFM=,&DEN=,&DSORG=,&KEYLEN=
         GBLC  &DYNP
         AIF   ('&DEN' EQ '').DSORG
         SPACE
***********************************************************************
**   DCB DENSITY TEXT UNIT                                           **
***********************************************************************
         AIF   ('&DEN' EQ '0').DEN0
         AIF   ('&DEN' EQ '1').DEN1
         AIF   ('&DEN' EQ '2').DEN2
         AIF   ('&DEN' EQ '3').DEN3
         AIF   ('&DEN' EQ '4').DEN4
         MNOTE 8,'DENSITY INVALID'
         AGO   .DSORG
.DEN0    ANOP
         MVI   S99TUPAR,X'03'          SET PARAMETER
         AGO   .DODEN
.DEN1    ANOP
         MVI   S99TUPAR,X'43'          SET PARAMETER
         AGO   .DODEN
.DEN2    ANOP
         MVI   S99TUPAR,X'83'          SET PARAMETER
         AGO   .DODEN
.DEN3    ANOP
         MVI   S99TUPAR,X'C3'          SET PARAMETER
         AGO   .DODEN
.DEN4    ANOP
         MVI   S99TUPAR,X'D3'          SET PARAMETER
         AGO   .DODEN
.DODEN   ANOP
         MVI   S99TUKEY+1,DALDEN       SET TEXT UNIT KEY
         MVI   S99TUNUM+1,1            SET NUMBER
         MVI   S99TULNG+1,1            SET LENGTH
         RCPDINC 8
.DSORG   AIF   ('&DSORG' EQ '').BLKSIZE
         SPACE
***********************************************************************
**    DCB DSORG TEXT UNIT                                            **
***********************************************************************
         AIF   ('&DSORG' EQ 'PO').PO
         AIF   ('&DSORG' EQ 'PS').PS
         AIF   ('&DSORG' EQ 'PO').DA
         MNOTE 8,'DSORG INVALID'
         AGO   .BLKSIZE
.PO      ANOP
         MVC   S99TUPAR(2),=X'0200'    SET PARAMETER
         AGO   .DODSORG
.PS      ANOP
         MVC   S99TUPAR(2),=X'4000'    SET PARAMETER
         AGO   .DODSORG
.DA      ANOP
         MVC   S99TUPAR(2),=X'2000'    SET PARAMETER
         AGO   .DODSORG
.DODSORG ANOP
         MVI   S99TUKEY+1,DALDSORG     SET TEXT UNIT KEY
         MVI   S99TUNUM+1,1            SET NUMBER
         MVI   S99TULNG+1,2            SET LENGTH
         RCPDINC 8
.BLKSIZE ANOP
         AIF   ('&BLKSIZE' EQ '').LRECL
         SPACE
***********************************************************************
**    DCB BLKSIZE TEXT UNIT                                          **
***********************************************************************
         MVI   S99TUKEY+1,DALBLKSZ     SET TEXT UNIT KEY
         MVI   S99TUNUM+1,1            SET NUMBER
         MVI   S99TULNG+1,2            SET LENGTH
         MVC   S99TUPAR(2),=AL2(&BLKSIZE) SET PARAMETER
         RCPDINC 10
.LRECL   ANOP
         AIF   ('&LRECL' EQ '').RECFM
         SPACE
***********************************************************************
**    DCB LRECL TEXT UNIT                                            **
***********************************************************************
         MVI   S99TUKEY+1,DALLRECL     SET TEXT UNIT KEY
         MVI   S99TUNUM+1,1            SET NUMBER
         MVI   S99TULNG+1,2            SET LENGTH
         MVC   S99TUPAR(2),=AL2(&LRECL) SET PARAMETER
         RCPDINC 10
.RECFM   ANOP
         AIF   ('&RECFM' EQ '').KEYLEN
         SPACE
***********************************************************************
**    DCB RECFM TEXT UNIT                                            **
***********************************************************************
         AIF   ('&RECFM' EQ 'F').RF
         AIF   ('&RECFM' EQ 'FA').RFA
         AIF   ('&RECFM' EQ 'FM').RFM
         AIF   ('&RECFM' EQ 'FB').RFB
         AIF   ('&RECFM' EQ 'FBM').RFBM
         AIF   ('&RECFM' EQ 'FBA').RFBA
         AIF   ('&RECFM' EQ 'V').RV
         AIF   ('&RECFM' EQ 'VA').RVA
         AIF   ('&RECFM' EQ 'VM').RVM
         AIF   ('&RECFM' EQ 'VB').RVB
         AIF   ('&RECFM' EQ 'VBM').RVBM
         AIF   ('&RECFM' EQ 'VBA').RVBA
         AIF   ('&RECFM' EQ 'U').RU
         MNOTE 8,'INVALID RECFM'
         AGO   .KEYLEN
.RF      ANOP
         MVI   S99TUPAR,X'80'
         AGO   .DORECFM
.RFA     ANOP
         MVI   S99TUPAR,X'84'
         AGO   .DORECFM
.RFM     ANOP
         MVI   S99TUPAR,X'82'
         AGO   .DORECFM
.RFB     ANOP
         MVI   S99TUPAR,X'90'
         AGO   .DORECFM
.RFBA    ANOP
         MVI   S99TUPAR,X'94'
         AGO   .DORECFM
.RFBM    ANOP
         MVI   S99TUPAR,X'92'
         AGO   .DORECFM
.RFBS    ANOP
         MVI   S99TUPAR,X'9A'
         AGO   .DORECFM
.RV      ANOP
         MVI   S99TUPAR,X'40'
         AGO   .DORECFM
.RVA     ANOP
         MVI   S99TUPAR,X'44'
         AGO   .DORECFM
.RVM     ANOP
         MVI   S99TUPAR,X'42'
         AGO   .DORECFM
.RVB     ANOP
         MVI   S99TUPAR,X'50'
         AGO   .DORECFM
.RVBA    ANOP
         MVI   S99TUPAR,X'54'
         AGO   .DORECFM
.RVBM    ANOP
         MVI   S99TUPAR,X'52'
         AGO   .DORECFM
.RVBS    ANOP
         MVI   S99TUPAR,X'5A'
         AGO   .DORECFM
.RU      ANOP
         MVI   S99TUPAR,X'C0'
         AGO   .DORECFM
.DORECFM ANOP
         MVI   S99TUKEY+1,DALRECFM     SET TEXT UNIT KEY
         MVI   S99TUNUM+1,1            SET NUMBER
         MVI   S99TULNG+1,1            SET LENGTH
         RCPDINC 8
.KEYLEN  ANOP
         AIF   ('&KEYLEN' EQ '').EXIT
         SPACE
***********************************************************************
**    DCB KEYLEN TEXT UNIT                                           **
***********************************************************************
         MVI   S99TUKEY+1,DALKYLEN     SET TEXT UNIT KEY
         MVI   S99TUNUM+1,1            SET NUMBER
         MVI   S99TULNG+1,1            SET LENGTH
         MVI   S99TUPAR,AL1(&KEYLEN)   SET PARAMETER
         RCPDINC 8
.EXIT    MEND
./ ADD NAME=RCPDDN   0100-03065-03065-2223-00027-00027-00000-DYNALLC
         MACRO
         RCPDDN &DDN
         GBLC  &DYNP
         SPACE 1
***********************************************************************
**   BUILD THE DDNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU
         AIF   ('&DDN'(1,1) EQ '''').Q
         RCPSR2
         AIF   ('&DDN'(1,1) EQ '(').R
         L     R14,&DDN                LOAD ADDRESS OF DDNAME
         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME
         AGO   .STH
.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME
         LH    R2,4&DDN                LOAD LENGTH OF DDNAME
.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DDNAME
         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.Q       RCPBTU DALDDNAM,1,&DDN
         MEXIT
.BTU     RCPTUBFR DALDDNAM,14,&DDN
         MEND
./ ADD NAME=RCPDDNRT 0100-03065-03065-2223-00012-00012-00000-DYNALLC
         MACRO
         RCPDDNRT
         SPACE 1
***********************************************************************
**    DDNAME RETURN TEXT UNIT                                        **
***********************************************************************
         MVI   S99TUKEY+1,DALRTDDN     SET RETURN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,8            SET LENGTH FIELD
         MVC   S99TUPAR(8),=CL8' '     INITIALIZE FIELD TO BLANKS
         RCPDINC 14
         MEND
./ ADD NAME=RCPDEBUG 0100-03065-03065-2223-00019-00019-00000-DYNALLC
         MACRO
         RCPDEBUG &ON
         GBLA  &RCPBGN#,&RCPSWS(10)
         GBLB  &RCPDBUG
         GBLC  &RCPPRE,&RCPWKDS,&RCPWKCS
         AIF   ('&ON' EQ '').TSW
&RCPDBUG SETB 1
.TSW     AIF   (&RCPDBUG).DEBUG
         MEXIT
.DEBUG   MNOTE *,'RCPBGN# IS &RCPBGN#'
         MNOTE *,'RCPSWS(1) IS &RCPSWS(1)'
         MNOTE *,'RCPSWS(2) IS &RCPSWS(2)'
         MNOTE *,'RCPSWS(3) IS &RCPSWS(3)'
         MNOTE *,'RCPSWS(4) IS &RCPSWS(4)'
         MNOTE *,'RCPSWS(5) IS &RCPSWS(5)'
         MNOTE *,'RCPWKCS IS ''&RCPWKCS'''
         MNOTE *,'RCPWKDS IS ''&RCPWKDS'''
         MNOTE *,'RCPPRE IS ''&RCPPRE'''
         MEND
./ ADD NAME=RCPDEFER 0100-03065-03065-2223-00009-00009-00000-DYNALLC
         MACRO
         RCPDEFER
         SPACE
***********************************************************************
**     DEFER VOLUME MOUNT TEXT ATTRIBUTE UNIT                        **
***********************************************************************
         MVI   S99TUKEY+1,DALDEFER     SET TEXT UNIT KEY
         RCPDINC  4
         MEND
./ ADD NAME=RCPDFPL  0100-03065-03065-2223-00044-00044-00000-DYNALLC
         MACRO
         RCPDFPL
         GBLC  &RCPPRE
         GBLB  &RCPDFPL(2)
         GBLB  &RCPDFPB(2)
         LCLC  &P,&L,&L1
&P       SETC  '&RCPPRE'
         EJECT
         AIF   (&RCPDFPL(2)).BYPDFPL
&RCPDFPL(2) SETB 1
         IKJDFPL
L#DFPL   EQU   *-DFPL                  LENGTH OF DEFAULT PARAM LIST
         IKJDFPB
L#DFPB   EQU   *-DFPB                  LENGTH OF DEFAULT PARAM BLOCK
&SYSECT  CSECT                         RESUME PROGRAM CSECT
         SPACE 3
.BYPDFPL RCPDS
&P.DFPL  DS    CL(L#DFPL)              RESERVE SPACE FOR DFPL
&P.DFPB  DS    CL(L#DFPB)              RESERVE SPACE FOR DFPB
&P.DSNB  DS    CL48                    RESERVE SPACE FOR DSNAME BUFFER
         RCPDS
         EJECT
***********************************************************************
***   THIS CODE GENERATES AN DEFAULT SERVICE ROUTINE PARAMETER LIST ***
***       AND PARAMETER BLOCK                                       ***
***********************************************************************
         LA    R1,&P.DFPL              LOAD DFPL ADDRESS
         USING DFPL,R1                 DFPL ADDRESSABLE
         MVC   DFPLUPT,CPPLUPT         MOVE IN ADDRESS OF UPT
         MVC   DFPLECT,CPPLECT         MOVE IN ADDRESS OF ECT
         LA    R15,&P.ECB              LOAD ADDRESS OF ATTN ECB
         ST    R15,DFPLECB             AND STORE IN DFPL
         LA    R15,&P.DFPB             LOAD DFBP ADDRESS
         ST    R15,DFPLDFPB             AND STORE IT IN DFPB
         DROP  R1
         USING DFPB,R15                ADDRESS DFPB DSECT
         XC    DFPB(L#DFPB),DFPB       CLEAR DEFAULT PARAMETER BLOCK
         MVC   DFPBPSCB,CPPLPSCB       MOVE IN ADDRESS OF PSCB
         LA    R1,&P.DSNB              LOAD DSNAME BUFFER ADDRESS
         ST    R1,DFPBDSN               AND STORE IT INTO DFPB
         MVI   DFPBCODE,DFPB04          SET ENTRY CODE
         DROP  R15                     DFPB NO LONGER ADDRESSABLE
         EJECT
         MEND
./ ADD NAME=RCPDINC  0100-03065-03065-2223-00013-00013-00000-DYNALLC
         MACRO
         RCPDINC &L1
         GBLA  &DTUO,&DTUPO
         GBLC  &DYNP
         AIF   ('&L1' EQ '').T2
         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT
&DTUPO   SETA  &DTUPO+4
&DTUO    SETA  &DTUO+&L1
         MEXIT
.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
&DTUPO   SETA  &DTUPO+4
         MEND
./ ADD NAME=RCPDISP  0100-03065-03065-2223-00053-00053-00000-DYNALLC
         MACRO
         RCPDISP &DISP
         LCLA  &I
         LCLB  &B(4)
         AIF   ('&DISP(1)' EQ '').TD2
         SPACE
***********************************************************************
**     DATA SET INITIAL STATUS                                       **
***********************************************************************
&B(1)    SETB  ('&DISP(1)' EQ 'SHR')
&B(2)    SETB  ('&DISP(1)' EQ 'NEW')
&B(3)    SETB  ('&DISP(1)' EQ 'MOD')
&B(4)    SETB  ('&DISP(1)' EQ 'OLD')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1
         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'
&B(1)    SETB  1
.OK1     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')
         RCPDINC 8
.TD2     AIF   ('&DISP(2)' EQ '').TD3
         SPACE
***********************************************************************
**    DATA SET NORMAL DISPOSITION                                    **
***********************************************************************
&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')
&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')
&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')
&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2
         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'
&B(1)    SETB  1
.OK2     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')
         RCPDINC 8
.TD3     AIF   ('&DISP(3)' EQ '').EXIT
         SPACE
***********************************************************************
**   DATASET CONDITIONAL DISPOSITION                                 **
***********************************************************************
&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')
&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')
&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')
&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3
         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'
&B(1)    SETB  1
.OK3     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')
         RCPDINC 8
.EXIT    MEND
./ ADD NAME=RCPDS    0100-03065-03065-2223-00026-00026-00000-DYNALLC
         MACRO
         RCPDS
         GBLB  &RCPDSBR
         GBLC  &RCPWKDS,&RCPWKCS,&RCPDS
         AIF   ('&RCPDS' NE '').RESUME
&RCPDS   SETC  '&SYSECT'
         AIF   ('&RCPWKDS' EQ '').CSECT
&RCPWKDS DSECT                         ENTER WORKAREA DSECT
         MEXIT
.CSECT   AIF   ('&RCPWKCS' EQ '').BRANCH
&RCPWKCS CSECT                         ENTER WORKAREA CSECT
         MEXIT
.RESUME  AIF   (&RCPDSBR).BRTO
&RCPDS   CSECT                         RESUME PROGRAM CSECT
&RCPDS   SETC  ''
         MEXIT
.BRANCH  ANOP
&RCPDS   SETC  'RCP&SYSNDX'
&RCPDSBR SETB  1
         B     &RCPDS                  BRANCH AROUND CONSTANTS
         MEXIT
.BRTO    ANOP
&RCPDS   DS    0H
&RCPDSBR SETB  0
&RCPDS   SETC  ''
         MEND
./ ADD NAME=RCPDSECT 0100-03065-03065-2223-00011-00011-00000-DYNALLC
         MACRO
&NAME    RCPDSECT &LTORG=YES
         AIF   ('&LTORG' NE 'YES').RCPDS
***********************************************************************
****                  LITERALS                                     ****
***********************************************************************
         SPACE 3
         LTORG
         EJECT
.RCPDS   RCPDS
         MEND
./ ADD NAME=RCPDSN   0100-03065-03065-2223-00068-00068-00000-DYNALLC
         MACRO
         RCPDSN &DSN,&MEM
         LCLC  &MEMBER
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE DSNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DSN'(1,1) EQ '''').Q
         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD
         AIF   ('&DSN'(1,1) EQ '(').REG
         AIF   ('&DSN'  EQ '*').TERM
         RCPSR2
         L     R14,&DSN                LOAD ADDRESS OF DSNAME
         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME
.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DSNAME
         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 52
         AGO   .TMEMBER
.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME
         RCPSR2
         LH    R2,4&DSN                LOAD LENGTH OF DSNAME
         AGO   .STH
.TERM    MVI   S99TUKEY+1,DALTERM
         RCPDINC 4
         MEXIT
.BD      RCPTUBFR DALDSNAM,52,&DSN
         AGO   .TMEMBER
.Q       RCPBTU DALDSNAM,1,&DSN
.TMEMBER AIF   ('&MEM' EQ '').EXIT
         SPACE
***********************************************************************
**   BUILD THE MEMBER NAME TEXT UNIT                                 **
***********************************************************************
&MEMBER  SETC  '&MEM'
         AIF   ('&MEM' NE '*').MOK
         AIF   ('&DSN'(1,1) NE '''').MAST
         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'
         MEXIT
.MAST    ANOP
&MEMBER  SETC  '8+&DSN'
.MOK     ANOP
         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM
         RCPSR2
         AIF   ('&MEMBER'(1,1) EQ '(').RM
         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER
         AGO   .STHM
.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER
.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME
         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.BM      RCPTUBFR DALMEMBR,14,&MEMBER
         MEXIT
.QM      RCPBTU DALMEMBR,1,&MEMBER
.EXIT    MEND
./ ADD NAME=RCPDSNPD 0100-03065-03065-2223-00009-00009-00000-DYNALLC
         MACRO
         RCPDSNPD &PDE
         AIF   ('&PDE'(1,1) EQ '(').RPDE
         RCPDSN &PDE,8+&PDE
         RCPPSWD 16+&PDE
         MEXIT
.RPDE    RCPDSN &PDE,8&PDE
         RCPPSWD 16(&PDE)
         MEND
./ ADD NAME=RCPDSNRT 0100-03065-03065-2223-00011-00011-00000-DYNALLC
         MACRO
         RCPDSNRT
         SPACE
***********************************************************************
**    DSNAME RETURN TEXT UNIT                                        **
***********************************************************************
         MVI   S99TUKEY+1,DALRTDSN     SET RETURN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,44           SET LENGTH FIELD
         RCPDINC 52
         MEND
./ ADD NAME=RCPDSRGR 0100-03065-03065-2223-00012-00012-00000-DYNALLC
         MACRO
         RCPDSRGR
         SPACE
***********************************************************************
**    DSORG RETURN TEXT UNIT                                         **
***********************************************************************
         MVI   S99TUKEY+1,DALRTORG     SET RETURN DSORG KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,2            SET LENGTH FIELD
         XC    S99TUPAR(2),S99TUPAR    INITIALIZE FIELD TO ZERO
         RCPDINC 8
         MEND
./ ADD NAME=RCPDUMMY 0100-03065-03065-2223-00009-00009-00000-DYNALLC
         MACRO
         RCPDUMMY &DUMMY
         SPACE
***********************************************************************
**      DUMMY DATASET TEXT UNIT                                      **
***********************************************************************
         MVI   S99TUPAR+1,DALDUMMY     MOVE IN DUMMY DS TEXT UNIT KEY
         RCPDINC 4
         MEND
./ ADD NAME=RCPENDD  0100-03065-03065-2223-00037-00037-00000-DYNALLC
         MACRO
&NAME    RCPENDD
         GBLB  &RCPECT(2),&RCPUPT(2),&RCPPSCB(2),&RCPS99(2)
         GBLC  &RCPPRE,&RCPWKDS,&RCPDS
         LCLC  &P,&CS
&CS      SETC  '&RCPDS'                PROGRAM CSECT
         AIF   (NOT &RCPS99(1)).TDS
         DYNSPACE
.TDS     AIF   ('&RCPWKDS' EQ '').RCPDS
         DS    0D                      ALIGN TO DOUBLEWORD
&P       SETC  '&RCPPRE'
&P.WKLEN EQU   *-&RCPWKDS              LENGTH OF WORK AREA
.RCPDS   RCPDS
         EJECT
         AIF   (NOT &RCPECT(1) OR &RCPECT(2)).TRYUPT
         IKJECT
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPECT(2)     SETB           1
.TRYUPT  AIF   (NOT &RCPUPT(1) OR &RCPUPT(2)).TRYPSCB
         IKJUPT
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPUPT(2) SETB  1
.TRYPSCB AIF   (NOT &RCPPSCB(1) OR &RCPPSCB(2)).TRYS99
         IKJPSCB
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPPSCB(2) SETB  1
.TRYS99  AIF   (NOT &RCPS99(1) OR &RCPS99(2)).TRYREST
         IEFZB4D0
         EJECT
         IEFZB4D2
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPS99(2) SETB  1
.TRYREST MEND
./ ADD NAME=RCPFDDN  0100-03065-03065-2223-00027-00027-00000-DYNALLC
         MACRO
         RCPFDDN &DDN
         GBLC &DYNP
         SPACE
***********************************************************************
**        FREE DDNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DDN'(1,1) EQ '''').Q
         AIF   ('&DDN'(K'&DDN,1) EQ '/').B
         RCPSR2
         AIF   ('&DDN'(1,1) EQ '(').R
         L     R14,&DDN                LOAD ADDRESS OF DDNAME
         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME
         AGO   .STH
.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME
         LH    R2,4&DDN                LOAD LENGTH OF DDNAME
.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DDNAME
         MVI   S99TUKEY+1,DUNDDNAM     MOVE IN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.Q       RCPBTU DUNDDNAM,1,&DDN
         MEXIT
.B       RCPTUBFR DUNDDNAM,14,&DDN
         MEND
./ ADD NAME=RCPFDISP 0100-03065-03065-2223-00020-00020-00000-DYNALLC
         MACRO
         RCPFDISP &DISP
         LCLB  &B(4)
         LCLA  &I
         SPACE
***********************************************************************
**       OVERRIDING DISPOSITION                                      **
***********************************************************************
&B(1)    SETB  ('&DISP' EQ 'KEEP')
&B(2)    SETB  ('&DISP' EQ 'DELETE')
&B(3)    SETB  ('&DISP' EQ 'CATLG')
&B(4)    SETB  ('&DISP' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3
         MNOTE 8,'&DISP IS INVALID, DISP=KEEP USED'
&B(1)    SETB  1
.OK3     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DUNOVDSP,1,1,X'0&I.00')
         RCPDINC 8
.EXIT    MEND
./ ADD NAME=RCPFDSN
         MACRO
         RCPFDSN &DSN,&MEM
         LCLC  &MEMBER
         GBLC  &DYNP
         SPACE
***********************************************************************
**      FREE DATA SET TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DSN'(1,1) EQ '''').Q
         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD
         AIF   ('&DSN'(1,1) EQ '(').REG
         RCPSR2
         L     R14,&DSN                LOAD ADDRESS OF DSNAME
         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME
.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DSNAME
         MVI   S99TUKEY+1,DUNDSNAM     MOVE IN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 52
         AGO   .TMEMBER
.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME
         RCPSR2
         LH    R2,4&DSN                LOAD LENGTH OF DSNAME
         AGO   .STH
.BD      RCPTUBFR DUNDSNAM,52,&DSN
         AGO   .TMEMBER
.Q       RCPBTU DUNDSNAM,1,&DSN
.TMEMBER AIF   ('&MEM' EQ '').EXIT
         SPACE
***********************************************************************
**       FREE MEMBER NAME TEXT UNIT                                  **
***********************************************************************
&MEMBER  SETC  '&MEM'
         AIF   ('&MEM' NE '*').MOK
         AIF   ('&DSN'(1,1) NE '''').MAST
         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'
         MEXIT
.MAST    ANOP
&MEMBER  SETC  '8+&DSN'
.MOK     ANOP
         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM
         RCPSR2
         AIF   ('&MEMBER'(1,1) EQ '(').RM
         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER
         AGO   .STHM
.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER
.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME
         MVI   S99TUKEY+1,DUNMEMBR     MOVE IN MEMBER KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.BM      RCPTUBFR DUNMEMBR,14,&MEMBER
         MEXIT
.QM      RCPBTU DUNMEMBR,1,&MEMBER
.EXIT    MEND
./ ADD NAME=RCPFHOLD
         MACRO
         RCPFHOLD &H
         AIF   ('&H' EQ 'YES').YES
         AIF   ('&H' EQ 'NO').NO
         MNOTE 4,'HOLD PARMETER VALUE INCORRECT - IGNORED'
         MEXIT
.YES     ANOP
         SPACE 1
***********************************************************************
**       OVERIDING SYSOUT HOLD TEXT UNIT                             **
***********************************************************************
         SPACE 1
         MVI   S99TUKEY+1,DUNOVSHQ MOVE IN TEXT UNIT KEY
         RCPDINC 4
         MEXIT
.NO      ANOP
         SPACE 1
***********************************************************************
**       OVERIDING SYSOUT NO HOLD TEXT UNIT                          **
***********************************************************************
         SPACE 1
         MVI   S99TUKEY+1,DUNOVSHQ MOVE IN TEXT UNIT KEY
         RCPDINC 4
         MEND
./ ADD NAME=RCPFORUS
         MACRO - TO SET UP SVC 99 TEXT UNIT 'FOR USER'
         RCPFORUS &T
         SPACE 1
***********************************************************************
**       'FOR USER' TEXT UNIT                                        **
***********************************************************************
         RCPVCHAR 0,8,&T,N=DALUSRID
         MEND
./ ADD NAME=RCPFREE
         MACRO
         RCPFREE &FREE
         SPACE
***********************************************************************
**      UNALLOC AT CLOSE TEXT UNIT                                   **
***********************************************************************
         MVI   S99TUPAR+1,DALCLOSE     MOVE IN CLOSE TEXT UNIT KEY
         RCPDINC 4
         MEND
./ ADD NAME=RCPIOPL
         MACRO
&NAME    RCPIOPL
         GBLC  &RCPPRE
         GBLB  &RCPIOPL(2)
         GBLB  &RCPSTPB(2),&RCPPTPB(2),&RCPPGPB(2),&RCPGTPB(2)
         LCLC  &P,&L,&L1
&P       SETC  '&RCPPRE'
         EJECT
         AIF   (&RCPIOPL(2)).BYPIOPL
&RCPIOPL(2) SETB 1
         IKJIOPL
L#IOPL   EQU   *-IOPL                  LENGTH OF IO PARAM LIST
&SYSECT  CSECT                         RESUME PROGRAM CSECT
         SPACE 3
.BYPIOPL RCPDS
&P.IOPL  DS    CL(L#IOPL)              RESERVE SPACE FOR IOPL
         RCPDS
         SPACE 5
***********************************************************************
***   THIS CODE GENERATES AN I/O SERVICE ROUTINE PARAMETER LIST     ***
***********************************************************************
         LA    R1,&P.IOPL              LOAD IOPL ADDRESS
         USING IOPL,R1                 IOPL ADDRESSABLE
         MVC   IOPLUPT,CPPLUPT         MOVE IN ADDRESS OF UPT
         MVC   IOPLECT,CPPLECT         MOVE IN ADDRESS OF ECT
         LA    R15,&P.ECB              LOAD ADDRESS OF ATTN ECB
         ST    R15,IOPLECB             AND STORE IN IOPL
         DROP  R1
  AIF (&RCPSTPB(1) OR &RCPGTPB(1) OR &RCPPGPB(1) OR &RCPPTPB(1)).I
         MEXIT
.I       EJECT
         AIF   (NOT &RCPSTPB(1) OR &RCPSTPB(2)).TPT
         IKJSTPB
&RCPSTPB(2) SETB 1
L#STPB   EQU   *-STPB         LENGTH OF STPB
&SYSECT  CSECT
.TPT     AIF   (NOT &RCPPTPB(1) OR &RCPPTPB(2)).TGT
         IKJPTPB
&RCPPTPB(2) SETB 1
L#PTPB   EQU   *-PTPB         LENGTH OF PTPB
&SYSECT  CSECT
.TGT     AIF   (NOT &RCPGTPB(1) OR &RCPGTPB(2)).TPG
         IKJGTPB
&RCPGTPB(2) SETB 1
L#GTPB   EQU   *-GTPB         LENGTH OF GTPB
&SYSECT  CSECT
.TPG     AIF   (NOT &RCPPGPB(1) OR &RCPPGPB(2)).STO
         IKJPGPB
&RCPPGPB(2) SETB 1
L#PGPB   EQU   *-PGPB         LENGTH OF PGPB
&SYSECT  CSECT
.STO     SPACE 3
&L       SETC  ''
         RCPDS
         AIF   (NOT &RCPSTPB(1)).XPT
&P.STPB  DS    CL(L#STPB)              RESERVE SPACE FOR STPB
&L       SETC  '&L.+L#STPB'
.XPT     AIF   (NOT &RCPPTPB(1)).XGT
&P.PTPB  DS    CL(L#PTPB)              RESERVE SPACE FOR PTPB
&L       SETC  '&L.+L#PTPB'
.XGT     AIF   (NOT &RCPGTPB(1)).XPG
&P.GTPB  DS    CL(L#GTPB)              RESERVE SPACE FOR GTPB
&L       SETC  '&L.+L#GTPB'
.XPG     AIF   (NOT &RCPPGPB(1)).XC
&P.PGPB  DS    CL(L#PGPB)              RESERVE SPACE FOR PGPB
&L       SETC  '&L.+L#PGPB'
.XC      RCPDS
&L1      SETC  '&L'(2,K'&L-1)
&L       SETC  '&P'.'&L1'(3,4)
         XC    &L.(&L1.),&L            CLEAR IOPB AREA
         MEND
./ ADD NAME=RCPLINK
         MACRO
&NAME    RCPLINK &MODULE
         LCLC  &OFFSET,&C
         AIF   ('&MODULE' EQ '').ERROR
         AIF   ('&MODULE' NE 'IKJPARS').T1
&OFFSET  SETC  '524'
         AGO   .START
.T1      AIF   ('&MODULE' NE 'IKJDAIR').T2
&OFFSET  SETC  '732'
         AGO   .START
.T2      AIF   ('&MODULE' NE 'IKJEHDEF').T3
&OFFSET  SETC  '736'
         AGO   .START
.T3      AIF   ('&MODULE' NE 'IKJEHCIR').T4
&OFFSET  SETC  '740'
         AGO   .START
.T4      AIF   ('&MODULE' NE 'IKJPUTL').T5
&OFFSET  SETC  '444'
         AGO   .START
.T5      AIF   ('&MODULE' NE 'IKJGETL').T6
&OFFSET  SETC  '348'
         AGO   .START
.T6      AIF   ('&MODULE' NE 'IKJSCAN').T7
&OFFSET  SETC  '480'
         AGO   .START
.T7      AIF   ('&MODULE' NE 'IKJPTGT').T8
&OFFSET  SETC  '464'
         AGO   .START
.T8      AIF   ('&MODULE' NE 'IKJSTCK').T9
&OFFSET  SETC  '472'
         AGO   .START
.T9      ANOP
&NAME    DS    0H
*
 MNOTE *,' EP OF &MODULE. NOT IN CVT. STANDARD LINK USED'
*
         AGO   .LINK
.START   ANOP
&NAME    L     R15,16                  LOAD CVT ADDRESS
         L     R15,&OFFSET.(R15)       LOAD MODULE ADDRESS
         LTR   R15,R15                 IS MODULE ADDRESS THERE?
&C       SETC  'RCP&SYSNDX'
         BNM   &C.L                     IF NOT, BRANCH TO LINK
         BALR  R14,R15                  ELSE BALR TO IT
         B     &C.B                      AND BYPASS LINK
&C.L     LINK  EP=&MODULE
&C.B     DS    0H                      BRANCHED TO IF LINK BYPASSED
         MEXIT
.LINK    ANOP
&NAME    LINK  EP=&MODULE
         MEXIT
.ERROR   MNOTE 4,'NO MODULE NAME SPECIFIED'
         MEND
./ ADD NAME=RCPLOAD
         MACRO
&NAME    RCPLOAD &MOD,&EP1
         GBLC  &RCPPTEP,&RCPGTEP,&RCPPGEP
         GBLC  &RCPDFEP,&RCPSTEP,&RCPPREP
         GBLC  &RCPPRE
         LCLA  &I,&J
         LCLB  &EPXISTS
         LCLC  &OFFSET,&C,&EP,&MODULE
&EP      SETC  '&EP1'
&MODULE  SETC  '&MOD'
         AIF   ('&MODULE' EQ '').ERROR
         AIF   ('&MODULE'(K'&MOD,1) NE ')').NOBR
&I       SETA  K'&MOD
.LOOP    ANOP
&I       SETA  &I-1
         AIF   (&I LT 2).NOLB
         AIF   ('&MOD'(&I,1) NE '(').LOOP
&MODULE  SETC  '&MOD'(1,&I-1)
&J       SETA  K'&MOD-1-&I
&EP      SETC  '&MOD'(&I+1,&J)
         RCPDS
&EP      DS    F                       TO STORE MODULE ADDRESS
         RCPDS
.NOBR    ANOP
&EPXISTS  SETB  ('&EP' NE '')
         AIF   ('&MODULE' NE 'IKJPARS').T1
&OFFSET  SETC  '524'
&RCPPREP SETC '&EP'
         AIF   (&EPXISTS).START
         RCPDS
&RCPPREP SETC '&RCPPRE.PREP'
&EP      SETC  '&RCPPREP'
&RCPPREP DS    F                       TO HOLD ADDRESS OF IKJPARS
         RCPDS
         AGO   .START
.T1      AIF   ('&MODULE' NE 'IKJDAIR').T2
&OFFSET  SETC  '732'
         AGO   .START
.T2      AIF   ('&MODULE' NE 'IKJEHDEF').T3
&RCPDFEP SETC  '&EP'
&OFFSET  SETC  '736'
         AIF   (&EPXISTS).START
&RCPDFEP SETC  '&RCPPRE.DFEP'
         RCPDS
&RCPDFEP DS    F                       ADDR OF DEFAULT SERVICE ROUTINE
         RCPDS
&EP      SETC  '&RCPDFEP'
         AGO   .START
.T3      AIF   ('&MODULE' NE 'IKJEHCIR').T4
&OFFSET  SETC  '740'
         AGO   .START
.T4      AIF   ('&MODULE' NE 'IKJPUTL').T5
&RCPPTEP SETC  '&EP'
&OFFSET  SETC  '444'
         AIF   (&EPXISTS).START
&RCPPTEP SETC  '&RCPPRE.PTEP'
&EP      SETC  '&RCPPTEP'
         RCPDS
&RCPPTEP DS    F                       ADDR OF PUTLINE ROUTINE
         RCPDS
         AGO   .START
.T5      AIF   ('&MODULE' NE 'IKJGETL').T6
&RCPGTEP SETC  '&EP'
&OFFSET  SETC  '348'
         AIF   (&EPXISTS).START
&RCPGTEP SETC  '&RCPPRE.GTEP'
&EP      SETC  '&RCPGTEP'
         RCPDS
&RCPGTEP DS    F                       ADDR OF GETLINE ROUTINE
         RCPDS
         AGO   .START
.T6      AIF   ('&MODULE' NE 'IKJSCAN').T7
&OFFSET  SETC  '480'
         AGO   .START
.T7      AIF   ('&MODULE' NE 'IKJPTGT').T8
&RCPPGEP SETC  '&EP'
&OFFSET  SETC  '464'
         AIF   (&EPXISTS).START
&RCPPGEP SETC  '&RCPPRE.PGEP'
&EP      SETC  '&RCPPGEP'
         RCPDS
&RCPPGEP DS    F                       ADDR OF PUTGET ROUTINE
         RCPDS
         AGO   .START
.T8      AIF   ('&MODULE' NE 'IKJSTCK').T9
&RCPSTEP SETC  '&EP'
&OFFSET  SETC  '472'
         AIF   (&EPXISTS).START
&RCPSTEP SETC  '&RCPPRE.STEP'
&EP      SETC  '&RCPSTEP'
         RCPDS
&RCPSTEP DS    F                       ADDR OF STACK ROUTINE
         RCPDS
         AGO   .START
.T9      ANOP
&NAME    DS    0H
*
 MNOTE *,' EP OF &MODULE. NOT IN CVT. STANDARD LOAD USED'
*
         AGO   .LOAD
.START   ANOP
&NAME    L     R15,16                  LOAD CVT ADDRESS
         L     R0,&OFFSET.(R15)        LOAD MODULE ADDRESS
         LTR   R0,R0                   IS MODULE LOADED?
&C       SETC  'RCP&SYSNDX'
         BM    &C                      IF SO, BYPASS LOAD MACRO
.LOAD    LOAD EP=&MODULE.
         AIF   ('&EP' EQ '').EPERR
&C       ST    R0,&EP                  STORE ENTRY POINT ADDRESS
         MEXIT
.EPERR   MNOTE 4,'EP RETURN FIELD NOT SPECIFIED'
         MEXIT
.ERROR   MNOTE 4,'NO MODULE NAME SPECIFIED'
         MEXIT
.NOLB    MNOTE 4,'INVALID MODULE NAME ''&MOD'''
         MEND
./ ADD NAME=RCPLOCSW
*23456789*12345*78921234567893123456789*
         MACRO
         RCPLOCSW &SW
.********************************************************************
.*                                                                  *
.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *
.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *
.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *
.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *
.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *
.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *
.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *
.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *
.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *
.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *
.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *
.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*
.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *
.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *
.*       BIT IN THE LIST.                                           *
.*                                                                  *
.********************************************************************
         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES
         GBLA  &RCPDSW0                NO OF SWS FOUND BY RCPLOCSW
         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS
         GBLB  &RCPDSW3(20)   INVERT INDICATOR
         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES
         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES
         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES
         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES
         GBLC  &RCPDSW1(20)            SWITCH BYTE NAMES
         GBLC  &RCPDSW2(20)            SWITCH BIT NAME(S)
         LCLA  &I,&J,&K,&L,&M,&N
         LCLB  &NOT
         LCLC  &C,&SW1,&SW2
&RCPDSW0 SETA  0                       INITIALIZE
&N       SETA  N'&SW                   NO OF SWITCHES ENTERED
&J       SETA  &RCPDSW#*8+8            INDEX TO LAST DECLARED SW BIT
.LOOP1   AIF   (&M GE &N).EXIT        LOOP FOR EACH SW
&M       SETA  &M+1
&SW2     SETC  '&SW(&M)'               SWITCH TO SEARCH FOR
         AIF   ('&SW2' EQ '').LOOP1    SKIP IF NULL
&I       SETA  8                       INDEX TO FIRST DECLARED SW - 1
&NOT     SETB  0
         AIF   ('&SW2'(1,1) NE '¬' AND '&SW2'(1,1) NE '-').TNOT2
&SW2     SETC  '&SW2'(2,K'&SW2-1)       REMOVE NOT SIGN
&NOT     SETB  1                       INDICATE INVERT FUNCTION
         AGO   .LOOP1A                 CONTINUE
.TNOT2   AIF   (K'&SW2 LT 5).LOOP1A    CHECK LENGTH
         AIF   ('&SW2'(1,4) NE 'NOT-').LOOP1A  WAS SWITCH INVERTED?
&SW2     SETC  '&SW2'(5,K'&SW2-4)      STRIP OFF 'NOT-'
&NOT     SETB  1                       INDICATE INVERTED
.LOOP1A  AIF   (&I GE &J).TGEN         SEARCH NAME ARRAY
&I       SETA  &I+1
         AIF   ('&RCPDSWB(&I)' NE '&SW2').LOOP1A
.*
.*   WE FOUND IT
.*
&L       SETA  (&I-1)/8                INDEX TO BYTE NAME
&SW1     SETC  '&RCPDSWN(&L)'          GET BYTE NAME
.FOUNDSW ANOP                          HAVE WE HAD IT BEFORE?
&K       SETA  0
.SWL1    AIF   (&K GE &RCPDSW0).NEWSW1
&K       SETA  &K+1
         AIF   ('&RCPDSW1(&K)' NE '&SW1').SWL1
         AIF   (&RCPDSW3(&K) NE &NOT).SWL1  ENSURE INVERT BIT THE SAME
.*
.* WE FOUND IT
.*
&RCPDSW2(&K) SETC '&RCPDSW2(&K)+&SW2'  CONCATENATE CURRENT SW
         AGO   .LOOP1                  GO DO NEXT
.NEWSW1  ANOP
&RCPDSW0 SETA  &K+1                    NEXT SW BYTE INDEX
&RCPDSW1(&RCPDSW0) SETC '&SW1'         BYTE NAME
&RCPDSW2(&RCPDSW0) SETC '&SW2'         BIT NAME
&RCPDSW3(&RCPDSW0) SETB (&NOT)         SET INVERT INDICATOR
         AGO   .LOOP1                  GO DO NEXT
.TGEN    ANOP  SEARCH GENERIC NAME ARRAY
&I       SETA  0
&L       SETA  K'&SW2
.LOOP2   ANOP
&I       SETA  &I+1
         AIF   (&I GT &RCPGSW#).NOTFND
&C       SETC  '&RCPGSWB(&I)'
         AIF   (&L LT K'&C).LOOP2
         AIF   ('&SW2'(1,K'&C) NE '&C').LOOP2
&SW1     SETC  '&RCPGSWN(&I)'
         AGO   .FOUNDSW                EUREKA
.NOTFND  MNOTE 4,'SWITCH ''&SW2'' NOT DECLARED'
         AGO   .LOOP1
.EXIT    MEND
./ ADD NAME=RCPLOCS1
*23456789*12345*78921234567893123456789*
         MACRO
         RCPLOCSW &SW
.********************************************************************
.*                                                                  *
.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *
.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *
.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *
.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *
.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *
.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *
.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *
.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *
.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *
.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *
.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *
.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*
.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *
.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *
.*       BIT IN THE LIST.                                           *
.*                                                                  *
.********************************************************************
         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES
         GBLA  &RCPDSW0                NO OF SWS FOUND BY RCPLOCSW
         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS
         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES
         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES
         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES
         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES
         GBLC  &RCPDSW1(20)            SWITCH BYTE NAMES
         GBLC  &RCPDSW2(20)            SWITCH BIT NAME(S)
         LCLA  &I,&J,&K,&L,&M,&N       LOCAL COUNTERS
         LCLC  &C,&SW1,&SW2
&RCPDSW0 SETA  0                       INITIALIZE
&N       SETA  N'&SW                   NO OF SWITCHES ENTERED
&J       SETA  &RCPDSW#*8              INDEX TO LAST DECLARED SW BIT
.LOOP1   AIF   (&M GE &N).EXIT        LOOP FOR EACH SW
&M       SETA  &M+1
&SW2     SETC  '&SW(&M)'               SWITCH TO SEARCH FOR
         AIF   ('&SW2' EQ '').LOOP1    SKIP IF NULL
&I       SETA  8                       INDEX TO FIRST DECLARED SW - 1
.LOOP1A  AIF   (&I GE &J).TGEN         SEARCH NAME ARRAY
&I       SETA  &I+1
         AIF   ('&RCPDSWB(&I)' NE '&SW2').LOOP1A
.*
.*   WE FOUND IT
.*
&L       SETA  (&I-1)/8                INDEX TO BYTE NAME
&SW1     SETC  '&RCPDSWN(&L)'          GET BYTE NAME
.FOUNDSW ANOP                          HAVE WE HAD IT BEFORE?
&K       SETA  0
.SWL1    AIF   (&K GE &RCPDSW0).NEWSW1
&K       SETA  &K+1
         AIF   ('&RCPDSW1(&K)' NE '&SW1').SWL1
.*
.* WE FOUND IT
.*
&RCPDSW2(&K) SETC '&RCPDSW2(&K)+&SW2'  CONCATENATE CURRENT SW
         AGO   .LOOP1                  GO DO NEXT
.NENSW1  ANOP
&RCPDSW0 SETA  &K+1                    NEXT SW BYTE INDEX
&RCPDSW1(&RCPDSW0) SETC '&SW1'         BYTE NAME
&RCPDSW2(&RCPDSW0) SETC '&SW2'         BIT NAME
         AGO   .LOOP1                  GO DO NEXT
.TGEN    ANOP  SEARCH GENERIC NAME ARRAY
&I       SETA  0
&L       SETA  K'&SW2
.LOOP2   ANOP
&I       SETA  &I+1
         AIF   (&I GT &RCPGSW#).NOTFND
&SW1     SETC  '&RCPGSWN(&I)'
         AIF   (&L LT K'&SW1).LOOP2
         AIF   ('&SW1'(1,&L) NE '&SW2').LOOP2
         AGO   .FOUNDSW                EUREKA
.NOTFND  MNOTE 4,'SWITCH ''&SW2'' NOT DECLARED'
         AGO   .LOOP1
.EXIT    MEND
./ ADD NAME=RCPLOCS2
*23456789*12345*78921234567893123456789*
         MACRO
         RCPLOCSW &SW
.********************************************************************
.*                                                                  *
.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *
.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *
.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *
.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *
.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *
.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *
.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *
.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *
.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *
.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *
.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *
.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*
.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *
.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *
.*       BIT IN THE LIST.                                           *
.*                                                                  *
.********************************************************************
         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES
         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS
         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES
         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES
         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES
         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES
         GBLC  &RCPDSW1                SWITCH BYTE NAME
         GBLC  &RCPDSW2                SWITCH BIT NAME(S)
         LCLA  &I,&J,&K,&L,&M,&N       LOCAL COUNTERS
         LCLC  &C
&RCPDSW2 SETC  '&SW(1)'                EXTRACT 1ST SWITCH BIT
&J       SETA  &RCPDSW#*8+8            ARRAY POS OF LAST SW BIT
&I       SETA  8                       ARRAY POS-1 OF 1ST SW BIT
.LOOP1   AIF   (&I GE &J).TGEN         IF SW NOT FOUND IN 1ST ARRAY,
.*                                      GO SEARCH GENERIC NAME ARRAY
&I       SETA  &I+1
         AIF   ('&RCPDSWB(&I)' NE '&RCPDSW2').LOOP1  LOOK FOR MATCH
.*
.*       OK, WE'VE FOUND A MATCH.
.*
&I       SETA  (&I-1)/8               GET POS OF SWITCH BYTE
&RCPDSW1 SETC  '&RCPDSWN(&I)'         MOVE IT TO EXIT PARM VAR
&I       SETA  &I*8+1                 POINT TO 1ST SW BIT IN IT
&J       SETA  &I+8                   POINT TO LAST SW BIT IN IT
&M       SETA  N'&SW                  GET NO OF SWITCHES
&L       SETA  1
.*
.*       NOW WE PROCESS SUBSEQUENT SWITCHES IN THE LIST
.*
.LOOP2   AIF   (&L GE &M).EXIT        EXIT WHEN FINISHED
&L       SETA  &L+1                   POINT TO NEXT SW IN LIST
&C       SETC  '&SW(&L)'               EXTRACT IT
&RCPDSW2 SETC  '&RCPDSW2.+&C'           THEN APPEND TO PREVIOUS
.*
.*       NOW WE CHECK THAT THE SWITCH IS DECLARED IN THE SAME
.*       BYTE AS THE FIRST.
.*
&N       SETA  &I-1                     POINT TO 1ST BIT POS MINUS 1
.LOOP3   AIF   (&N GE &J).NM            IF SW NOT FOUND, ISSUE MNOTE
&N       SETA  &N+1                     POINT TO NEXT
         AIF   ('&C' NE '&RCPDSWB(&N)').LOOP3  SEARCH FOR MATCH
         AGO   .LOOP2                   IF FOUND, GO PROCESS NEXT
.NM      MNOTE 4,'WARNING: SWITCH ''&C'' NOT DECLARED IN SAME BYTE AS  X
               SWITCH ''&SW(1)'' - LOGIC ERROR MAY OCCUR'
         AGO   .LOOP2            CONTINUE FOR NEXT SWITCH BIT
.*
.*       IF THE SWITCH WAS NOT LOCATED IN THE EXPLICIT NAME ARRAY,
.*       THE GENERIC NAME ARRAY IS SEARCHED.
.*
.TGEN    ANOP
&I       SETA  0
&RCPDSW2 SETC  '&SW(1)'                EXTRACT 1ST SWITCH
&L       SETA  K'&RCPDSW2              GET LENGTH OF 1ST SW
.LOOP4   AIF   (&I GE &RCPGSW#).ERROR  IF NOT SW NOT DECLARED, ERROR
&I       SETA  &I+1
&C       SETC  '&RCPGSWB(&I)'          GET GENERIC PREFIX
&K       SETA  K'&C                    GET LENGTH OF GENERIC PREFIX
         AIF   (&L LT &K).LOOP4         AND SKIP IF LEN OF SWITCH NAME
.*                                          < LEN OF GENERIC PREFIX
         AIF   ('&RCPDSW2'(1,&K) NE '&C').LOOP4  ALSO SKIP IF NO MATCH
&RCPDSW1 SETC  '&RCPGSWN(&I)'          SAVE SWITCH BYTE NAME
&I       SETA   1
&J       SETA   N'&SW
.LOOP5   AIF   (&I GE &J).EXIT         EXIT WHEN FINISHED
&I       SETA   &I+1
&RCPDSW2 SETC   '&RCPDSW2.+&SW(&I)'     APPEND THIS SWITCH
         AIF    ('&SW(&I)    '(1,&K) EQ '&C').LOOP5 CHECK PREFIX
         MNOTE 4,'WARNING: SWITCH ''&SW(&I)'' NOT GENERICALLY EQUAL TO X
               SWITCH ''&SW(1)'''
         AGO   .LOOP5
.ERROR   MNOTE 8,'SWITCH ''&SW(1)'' NOT DECLARED'
&RCPDSW1 SETC  ''             INDICATE ERROR
.EXIT    MEND
./ ADD NAME=RCPMCA
         MACRO
         RCPMCA &DSECT=YES
         GBLC  &RCPPRE
         GBLA  &RCPSWS(10)
         LCLC  &P
     RCPDEBUG
&P       SETC  '&RCPPRE'
         AIF   (&RCPSWS(2) NE 2).DSECT
&P.MCA   DS    0F                      MODULE COMMUNICATIONS AREA
         AGO   .MCA2
.DSECT   ANOP
&P.MCA   DSECT                         MODULE COMMUNICATIONS AREA
.MCA2    ANOP
&P.XDS   DS    F                       ADDR OF EXTERNAL DUMMY SECTION
         AIF   (&RCPSWS(3) LT 1).EXIT
&P.A#GET DS    F                       ADDRESS OF LIFO GET ROUTINE
&P.A#FRE DS    F                       ADDRESS OF LIFO FREE ROUTINE
&P.#S    DS    F                       ADDRESS OF CURRENT LIFO STACK
&P.#E    DS    F                       ADDRESS OF END OF LIFO STACK
&P.#N    DS    F                       ADDRESS OF NEXT FREE AREA
&P.#C    DS    F                       ADDRESS OF NEXT LIFO STACK
&P.#L    DS    F                       LENGTH OF CURRENT LIFO STACK
.EXIT    MEND
./ ADD NAME=RCPMCLAS
         MACRO
         RCPMCLAS &MCLAS
         GBLC  &DYNP
         SPACE 1
***********************************************************************
**   BUILD THE MGMTCLAS TEXT UNIT                                    **
***********************************************************************
.MCLAS   RCPTUBFX DALMGCL,14,&MCLAS
         MEND
./ ADD NAME=RCPMSVGP
         MACRO
         RCPMSVGP &MSVGP
         GBLC  &DYNP
         SPACE 1
***********************************************************************
**   BUILD THE MSVGP TEXT UNIT                                       **
***********************************************************************
         AIF   ('&MSVGP'(K'&MSVGP,1) EQ '/').BTU
         AIF   ('&MSVGP'(1,1) EQ '''').Q
         RCPSR2
         AIF   ('&MSVGP'(1,1) EQ '(').R
         L     R14,&MSVGP              LOAD ADDRESS OF MSVGP
         LH    R2,&MSVGP+4             LOAD LENGTH OF MSVGP
         AGO   .STH
.R       L     R14,0&MSVGP             LOAD ADDRESS OF MSVGP
         LH    R2,4&MSVGP              LOAD LENGTH OF MSVGP
.STH     STH   R2,S99TULNG             STORE MSVGP LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE MSVGP
         MVI   S99TUKEY+1,DALMSVGP     MOVE IN MSVGP KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.Q       RCPBTU DALMSVGP,1,&MSVGP
         MEXIT
.BTU     RCPTUBFR DALMSVGP,14,&MSVGP
         MEND
./ ADD NAME=RCPNTU
         MACRO
         RCPNTU &KEY,&LEN,&PAR
.*
.*     THIS IS AN ALLOC/FREE MACRO TEXT UNIT PROCESSOR SUBROUTINE
.*     MACRO. IT BUILDS NUMERIC TYPE TEXT UNITS.
.*
         LCLA  &L,&R
         LCLC  &C
         GBLC  &RCPTYPE
.*  ALLOC/FREE INNER MACRO TO SET UP NUMERIC TEXT UNITS
&L       SETA  1                       DEFAULT LENGTH
         AIF   ('&LEN' EQ '').NL
&L       SETA  &LEN
.NL      MVI   S99TUKEY+1,&KEY         SET KEY FIELD
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,&L           SET LENGTH FIELD
         AIF   ('&PAR'(1,1) EQ '(').REG
         RCPTYPE &PAR                  ANALYSE PARAMETER
         AIF   ('&RCPTYPE' EQ 'N').NUMERIC
&R       SETA  4-&L
         MVC   S99TUPAR(&L),&R+&PAR    MOVE IN QUANTITY
         RCPDINC 10
         MEXIT
.NUMERIC AIF   (&L EQ 1).NL1
         MVC   S99TUPAR(&L.),=AL&L.(&PAR) MOVE IN QUANTITY
&R       SETA  &L+6
         AIF   (&R/2 EQ (&R+1)/2).LOK ENSURE LENGTH EVEN
&R       SETA  &R+1
.LOK     RCPDINC &R
         MEXIT
.NL1     MVI   S99TUPAR,&PAR           MOVE IN QUANTITY
         RCPDINC 8
         MEXIT
.REG     ANOP
&C       SETC  '&PAR'(2,K'&PAR-2)
         AIF   (&L EQ 3).STCM
         AIF   (&L EQ 2).STH
         AIF   (&L EQ 1).STC
         ST    &C,S99TUPAR             STORE TEXT UNIT QUANTITY
         AGO   .RCPDINC
.STH     STH   &C,S99TUPAR             STORE TEXT UNIT QUANTITY
         AGO   .RCPDINC
.STC     STC   &C,S99TUPAR             STORE TEXT UNIT QUANTITY
         AGO   .RCPDINC
.STCM    STCM  &C,7,S99TUPAR           STORE TEXT UNIT QUANTITY
.RCPDINC RCPDINC 10
         MEND
./ ADD NAME=RCPPERM
         MACRO
         RCPPERM
         SPACE
***********************************************************************
**     PERMANENTLY ALLOCATED ATTRIBUTE TEXT UNIT                     **
***********************************************************************
         MVI   S99TUKEY+1,DALPERMA     SET TEXT UNIT KEY
         RCPDINC  4
         MEND
./ ADD NAME=RCPPPL
         MACRO
&NAME    RCPPPL &PCL=,&NOPARM=,&PARSERR=,&PDLREG=R11,                  X
               &PDLNAME=,&PARSEP=,&PARSWKA=
         GBLB  &RCPPPL(2),&RCPECT(2)
         GBLC  &RCPPRE,&RCPPREP
         LCLC  &P
&P       SETC  '&RCPPRE'
         AIF   (&RCPPPL(2)).BPPL
         EJECT
         IKJPPL
L#PPL    EQU   *-PPL                   LENGTH OF PPL
&SYSECT  CSECT
         SPACE 1
&RCPPPL(2) SETB 1
.BPPL    RCPDS
&P.PPL   DS    CL(L#PPL)               RESERVE SPACE FOR PPL
&P.PDLP  DS    F                       POINTER TO PDL
         RCPDS
         SPACE 6
***********************************************************************
***   THIS CODE GENERATES A PARSE PARAMETER LIST                    ***
***********************************************************************
         XC    &P.PDLP,&P.PDLP         ZERO PDL POINTER
         AIF   ('&NOPARM(1)' EQ '' OR '&NOPARM(2)' NE '').PB2
         L     R1,CPPLECT              LOAD ECT ADDRESS
&RCPECT(1) SETB 1
         USING ECT,R1                  ECT ADDRESSABLE
         TM    ECTSWS,ECTNOPD          WERE ANY OPERANDS SUPPLIED?
         BO    &NOPARM(1)              NO, BRANCH OUT
         SPACE
.PB2     LA    R1,&P.PPL               LOAD PPL ADDRESS
         USING PPL,R1
         MVC   PPLUPT,CPPLUPT          MOVE IN UPT ADDRESS
         MVC   PPLECT,CPPLECT          MOVE IN ECT ADDRESS
         MVC   PPLCBUF,CPPLCBUF        MOVE IN CBUF ADDRESS
         LA    R15,&P.ECB              LOAD ATTN ECB ADDRESS
         ST    R15,PPLECB              AND STORE IN PPL
         LA    R15,&P.PDLP             LOAD PDL POINTER ADDRESS
         ST    R15,PPLANS               AND STORE IN PPL
         AIF   ('&PARSWKA' EQ '').PB3
         AIF   ('&PARSWKA'(1,1) EQ '').PB4
         LA    R15,&PARSWKA            LOAD ADDRESS OF WORK AREA
         ST    R15,PPLUWA               AND STORE IN PPL
         AGO   .PB3
.PB4     ST    &PARSWKA(1),PPLUWA      STORE ADDRESS OF WORKAREA
.PB3     AIF   ('&PCL' EQ '').EXIT
         L     R15,=V(&PCL)            LOAD PCL ADDRESS
         ST    R15,PPLPCL              AND STORE IN PPL
         SPACE 2
         AIF   ('&NOPARM(1)' EQ '' OR '&NOPARM(2)' EQ '').PB5
         L     R1,CPPLECT              LOAD ECT ADDRESS
&RCPECT(1) SETB 1
         USING ECT,R1
         TM    ECTSWS,ECTNOPD          WERE ANY OPERANDS SUPPLIED?
         BO    &NOPARM(1)               NO, BRANCH OUT
         SPACE
.PB5     AIF   ('&SYSPARM' EQ 'MVT').MVTBYP
         AIF   ('&RCPPREP' EQ '').NOPREP
         L     R15,&RCPPREP            LOAD EP OF IKJPARS
         BALR  R14,R15                  AND ENTER IT
         AGO   .PRET
.NOPREP  ANOP
         L     R15,16                  LOAD CVT ADDRESS
         TM    524(R15),X'80'          IS IKJPARS LOADED?
         AIF   ('&PARSEP' EQ '').PBL1
         BZ    &P.LOAD                  NO, BRANCH TO LOAD SVC
         L     R15,524(15)             LOAD EP OF IKJPARS
         ST    R15,&PARSEP             SAVE ITS ADDRESS
         BALR  R14,R15                 THEN BALR TO IT
         B     &P.PLNKB                BYPASS LOAD SVC
&P.LOAD  LOAD  EP=IKJPARS
         LR    R15,R0                  LOAD EP OF IKJPARS
         ST    R15,&PARSEP             SAVE IT
         BALR  R14,R15                 THEN BALR TO IT
&P.PLNKB DS    0H
         AGO   .PRET
.PBL1    BZ    &P.PLINK                 NO, BRANCH TO LINK SVC
         L     R15,524(R15)            ELSE LOAD ITS ADDRESS
         BALR  R14,R15                  AND BALR TO IT
         B     &P.PLNKB                BYPASS LINK SVC
.MVTBYP  ANOP
&P.PLINK LINK  EP=IKJPARS
&P.PLNKB DS    0H
.PRET    AIF   ('&PARSERR' EQ '').EXIT
         SPACE
         LTR   R15,R15                 TEST RETURN CODE
         BNZ   &PARSERR                 AND BRANCH ON NON-ZERO
         SPACE
         AIF   ('&PDLREG' EQ '' OR '&PDLNAME' EQ '').EXIT
         L     &PDLREG,&P.PDLP         LOAD PDL ADDRESS
         USING &PDLNAME,&PDLREG        PDL DSECT ADDRESSABLE
.EXIT    MEND
./ ADD NAME=RCPPROC
         MACRO
         RCPPROC &WKCSECT=,&WKDSECT=,                                  X
               &REG1=,&REG0=,&ISA=,&SAVEPRE=,                          X
               &SAVESUF=,&SP=
         GBLA  &RCPSWS(10)
         GBLC  &RCPPRE,&RCPWKCS,&RCPWKDS
         GBLC  &RCPSPN
         LCLC  &P,&C
         RCPDEBUG
&P       SETC  '&RCPPRE'
         AIF   ('&WKCSECT' EQ '').TDS
         SPACE
         MNOTE 4,'WKCSECT= OPTION INVALID WITH PROC OPTION, '
         MNOTE *,'    WKDSECT=  USED INSTEAD'
&RCPWKDS SETC  '&WKCSECT'
         AGO   .SETCS
.TDS     AIF   ('&WKDSECT' EQ '').SYSECT
&RCPWKDS SETC  '&WKDSECT'
         AGO   .SETCS
.SYSECT  ANOP
&RCPWKDS SETC  '&SYSECT'
.SET1    AIF   (K'&RCPWKDS LT 8).LOK
&RCPWKDS SETC  '&RCPWKDS'(1,4)'&RCPWKDS'(6,3)'1'
         AGO   .SETCS
.LOK     ANOP
&RCPWKDS SETC  '&RCPWKDS.1'
.SETCS   ANOP
&RCPWKCS SETC  ''
&RCPSWS(4) SETA &RCPSWS(2)-1 SET W/A TO BE FREED OPT IF PROC(MAIN)
         AIF   ('&ISA' EQ '').NISA
&RCPSWS(3) SETA 1                      SET LIFO FLAG IF ISA SPEC
.NISA    ANOP
         SPACE 2
         RCPDS
         DS    9D                      SAVE AREA
&P.RCODE DS    F                       RETURN CODE
         RCPMCA
         RCPDS
         SPACE 2
         AIF   ('&REG1' EQ '').TR0
         LR    &REG1,R1                SAVE CONTENTS OF REG 1
.TR0     AIF   ('&REG0' EQ '').TP
         LR    &REG0,R0                SAVE CONTENTS OF REG 0
.TP      AIF   (&RCPSWS(2) EQ 2).PROCMN   PROCMAIN OPTION
         AIF   (&RCPSWS(3) EQ 1).PL    LIFO OPTION
         L     R15,0(R13)              R15 -> MODULE COMMUNIC. AREA
         L     R15,&P.XDS-&P.MCA(R15)  LOAD EXTERNAL DUMMY SECT ADDR
         AL    R15,&P.QCON             GET OFFSET TO WORK AREA
         ST    R15,8(R13)              CHAIN SAVE
         ST    R13,4(R15)               AREAS TOGETHER
         MVC   0(4,R15),0(R13)         COPY POINTER TO COMM AREA
         LR    R13,R15                 LOAD WORK AREA ADDRESS
         USING &RCPWKDS,R13              ESTABLISH ADDRESSABLITY TO IT
         MEXIT
.PL      ANOP
***********************************************************************
*        GET WORKAREA FROM LIFO STACK                                 *
***********************************************************************
         #GET  LV=&P.WKLEN
         ST    R1,8(R13)               CHAIN SAVE
         ST    R13,4(R1)                AREAS TOGETHER
         MVC   0(4,R1),0(R13)          PROPAGATE MODULE COMM. AREA ADDR
         LR    R13,R1                  LOAD WORK AREA ADDRESS
         USING &RCPWKDS,R13             ESTABLISH ADDRESSABILITY TO IT
         MEXIT
.PROCMN  L     R0,&P.CXD               LOAD WORK AREA LENGTH
         AIF   ('&SYSPARM' EQ 'MVT').MVT
 MNOTE *,'      GETMAIN RU,LV=(0),SP=&SP,BNDRY=PAGE'
         GETMAIN RU,LV=(0),SP=&SP,BNDRY=PAGE
         AGO   .CONT
.MVT     AIF   ('&SP' EQ '').NOSP
         ICM   R0,8,=AL1(&SP)          INSERT SUBPOOL NUMBER
.NOSP    ANOP
*        GETMAIN R,LV=(0)              OBTAIN A WORK AREA
.CONT    ANOP
&RCPSPN  SETC  '&SP'
         LR    R15,R13                 SAVE CALLER'S SAVE AREA ADDR
         LR    R13,R1                  LOAD EXT DUMMY SECTION ADDR
         AL    R13,&P.QCON              ADD OFFSET TO WORK AREA
         ST    R13,8(R15)              CHAIN SAVE
         ST    R15,4(R13)               AREAS TOGETHER
         USING &RCPWKDS,R13            GET WORKAREA ADDRESSABILITY
         ST    R1,&P.XDS               STORE DUMMY SECTION ADDR IN     X
                                         MODULE COMMUNICATIONS AREA
         LA    R15,&P.MCA              STORE COMMUNICATIONS AREA ADDR
         ST    R15,0(R13)               IN WORD 1 OF SAVE AREA
         AIF   (&RCPSWS(3) EQ 0 AND '&ISA' EQ '').EXIT
&RCPSWS(3) SETA 1                      SET LIFO IN CASE ONLY ISA SPEC
&C       SETC  '&ISA'
         AIF   ('&ISA' NE '').TK
&C       SETC  '8192'
         AGO   .NK
.TK      AIF   ('&C'(K'&C,1) NE 'K').NK
&C       SETC  '&C'(1,K'&C-1)'*1024'
.NK      EJECT
***********************************************************************
**       INITIALIZE MODULE COMMUNICATIONS AREA WITH POINTERS         **
**       TO LIFO STACK AND LIFO GET/FREE ROUTINES                    **
***********************************************************************
         SPACE 1
         MVC   &P.A#GET,=V(#####GET)   MOVE LIFO GET AND FREE
         MVC   &P.A#FRE,=V(####FREE)    ROUTINE ADDRESSES TO MCA
         L     R15,=Q(#####ISA)        COMPUTE LIFO STACK
         AL    R15,&P.XDS               PSEUDO REGISTER OFFSET
         ST    R15,&P.#S                 AND INITIALIZE POINTERS
         ST    R15,&P.#N                  IN MODULE COMMUNICATIONS AREA
         L     R14,=A(&C)              LOAD SIZE OF INITIAL STACK AREA
         ST    R14,&P.#L               STORE THIS IN MCA
         ALR   R15,R14                  THEN COMPUTE STACK END ADDRESS
         ST    R15,&P.#E                 AND STORE THIS INTO MCA
         EJECT
***********************************************************************
**       LIFO STACK GET/FREE ROUTINES                                **
***********************************************************************
         SPACE 1
#####ISA DXD   CL(&C)                  DEFINE PSEUDO REGISTER FOR ISA
         SPACE 1
#####GET CSECT                         LIFO GET ROUTINE
         USING *,R15
         USING &P.MCA,R1
         A     R0,&P.F7                ROUND LENGTH UP TO
         N     R0,&P.F8                 A MULTIPLE OF 8
         AL    R0,&P.#N                COMPUTE NEXT FREE LIFO SLOT ADDR
         CL    R0,&P.#E                COMPARE TO STACK END ADDRESS
         BH    &P.GA                    AND IF TOO BIG, BRANCH
         LR    R15,R1                  PRESERVE MCA ADDRESS
         USING &P.MCA,R15              NEW BASE
         L     R1,&P.#N                LOAD ADDRESS OF SLOT
         ST    R0,&P.#N                 AND STORE ADDRESS OF NEXT SLOT
         BR    R14                     RETURN TO CALLER
         SPACE 1
&P.GA    EQU   *                       IF CURRENT SLOT TOO SMALL
*        ABEND 1000,DUMP                ABEND FOR NOW
         ABEND 1000,DUMP
         SPACE 2
####FREE DS    0H                      LIFO FREE ROUTINE
         ENTRY ####FREE
         USING *,R15                   BASE ADDRESS
         USING &P.MCA,R1               MCA ADDRESS
         CL    R0,&P.#S                CHECK THAT
         BL    &P.FA                    ADDRESS TO BE
         CL    R0,&P.#E                  FREED IS WITHIN
         BH    &P.FA                      BOUND OF CURRENT STACK
         AL    R0,&P.F7                GET UPPER DOUBLE
         N     R0,&P.F8                 WORD BOUNDARY
         ST    R0,&P.#N                  AND UPDATE MCA
         BR    R14                     RETURN TO CALLER
         SPACE 1
&P.FA    EQU   *                       IF ADDRESS NOT WITHIN THIS STACK
*        ABEND 1001,DUMP               ABEND
         ABEND 1001,DUMP
         SPACE 2
&P.F7    DC    F'7'                    CONSTANTS
&P.F8    DC    F'-8'                    TO ROUND UP TO DOUBLEWORD SIZE
         DROP  R1,R15                  KILL ADDRESSABILITY
&SYSECT  CSECT                         RESUME MAIN PROGRAM CSECT
.EXIT    MEND
./ ADD NAME=RCPPSWD
         MACRO
         RCPPSWD &PASSW
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE PASSWORD TEXT UNIT                                    **
***********************************************************************
         RCPVCHAR DALPASSW,14,&PASSW
         MEND
./ ADD NAME=RCPQNAME
         MACRO
         RCPQNAME &QNAME
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE QNAME TEXT UNIT                                       **
***********************************************************************
         RCPVCHAR DALQNAME,14,&QNAME
         MEND
./ ADD NAME=RCPRNGE
         MACRO - BREAK A RANGE PARAMETER INTO TWO
         RCPRNGE &P
         GBLC  &RCPRNGE(2)
         LCLA  &I,&J,&K
&K       SETA  K'&P
&RCPRNGE(1) SETC ''
&RCPRNGE(2) SETC ''
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &K).NR
         AIF   ('&P'(&I,1) NE '-' AND '&P'(&I,1) NE ':').LOOP
&RCPRNGE(1) SETC '&P'(1,&I-1)
&RCPRNGE(2) SETC '&P'(&I+1,&K-&I)
         MEXIT
.NR      ANOP
&RCPRNGE(1) SETC '&P'
         MEND
./ ADD NAME=RCPSCLAS
         MACRO
         RCPSCLAS &SCLAS
         GBLC  &DYNP
         SPACE 1
***********************************************************************
**   BUILD THE STORCLAS TEXT UNIT                                    **
***********************************************************************
.BTU     RCPTUBFX DALSTCL,14,&SCLAS
         MEND
./ ADD NAME=RCPSPACE
         MACRO
         RCPSPACE &SPACE
         GBLA  &RCPSUB#                NO OF SUBLIST ELEMENTS
         GBLC  &RCPSUBL(100)           SUBLIST ELEMENTS
.**********************************************************************
.*    THIS IS AN ALLOC INNER MACRO TO BUILD THE ALLOCATION SPACE
.*    QUANTITY TEXT UNIT. IT SHOULD BE SPECIFIED AS:-
.*     SPACE=(TYPE,(PRIMARY,SECONDARY,DIRECTORY),RLSE,CONTIG,ROUND)
.*   WHERE TYPE IS 'TRK', 'CYL', 'ABSTR' OR A BLOCK QUANTITY
.*     'CYL' OR 'TRK' SHOULD NOT BE ENTERED IN QUOTES. THE BLOCK
.*     QUANTITY CAN BE A NUMBER, A REGISTER (IN BRACKETS), OR THE
.*     NAME OF A FULLWORD CONTAINING THE BLOCK SIZE.
.**********************************************************************
         AIF   ('&SPACE(1)' EQ '' OR '&SPACE(1)' EQ 'TRK').TRK
         AIF   ('&SPACE(1)' EQ 'CYL').CYL
***********************************************************************
**        SPACE UNIT IN BLOCKS                                       **
***********************************************************************
         RCPNTU DALBLKLN,3,&SPACE(1)  GENERATE BLOCK UNIT TU
         AGO   .TPRIME        GO TEST PRIME QUANTITY
.TRK     ANOP  TRACK SPEC REQ OR DEFAULTED
         SPACE
***********************************************************************
**       SPACE QUANTITY IN TRACKS                                    **
***********************************************************************
         MVI   S99TUKEY+1,DALTRK       SET TEXT UNIT KEY
         RCPDINC 4
         AGO   .TPRIME
.CYL     ANOP  CYL QUANTITY
         SPACE 1
***********************************************************************
**      SPACE UNIT IN CYLINDERS                                      **
***********************************************************************
         MVI   S99TUKEY+1,DALCYL       SET TEXT UNIT KEY
         RCPDINC 4                     STORE TEXT UNIT ADDR
.TPRIME  RCPSUBL &SPACE(2)             BREAK UP SUBLIST
         AIF   (&RCPSUB# EQ 0).TCONTIG
         AIF   ('&RCPSUBL(1)' EQ '').TSP2
         SPACE
***********************************************************************
**       PRIMARY SPACE QUANTITY                                      **
***********************************************************************
         RCPNTU DALPRIME,3,&RCPSUBL(1)
.TSP2    AIF   (&RCPSUB# LT 2).TCONTIG
         AIF   ('&RCPSUBL(2)' EQ '').TSP3
         SPACE
***********************************************************************
**       SECONDARY SPACE QUANTITY                                    **
***********************************************************************
         RCPNTU DALSECND,3,&RCPSUBL(2)
.TSP3    AIF   (&RCPSUB# LT 3).TCONTIG
         AIF   ('&RCPSUBL(3)' EQ '').TCONTIG
         SPACE
***********************************************************************
**       DIRECTORY BLOCK QUANTITY                                    **
***********************************************************************
         RCPNTU DALDIR,3,&RCPSUBL(3)
.TCONTIG AIF  ('&SPACE(3)' EQ 'CONTIG' OR '&SPACE(4)' EQ 'CONTIG').CON
         AIF   ('&SPACE(3)' EQ 'MXIG' OR '&SPACE(4)' EQ 'MXIG').MXIG
         AIF   ('&SPACE(3)' EQ 'ALX' OR '&SPACE(4)' EQ 'ALX').ALX
.TRLSE   AIF   ('&SPACE(3)' EQ 'RLSE' OR '&SPACE(4)' EQ 'RLSE').RLSE
.TROUND  AIF   ('&SPACE(4)'EQ'ROUND'OR'&SPACE(5)'EQ'ROUND').ROUND
         MEXIT
.CON     ANOP
***********************************************************************
**      CONTIGUOUS SPACE TEXT UNIT                                   **
***********************************************************************
         RCPNTU DALSPFRM,1,8
         AGO   .TRLSE
.MXIG    ANOP
***********************************************************************
**       MAXIMUM CONTIGUOUS SPACE TEXT UNIT                          **
***********************************************************************
         RCPNTU DALSPFRM,1,4
         AGO   .TRLSE
.ALX     ANOP
***********************************************************************
**       'ALX' SPACE TEXT UNIT                                       **
***********************************************************************
         RCPNTU DALSPFRM,1,2
         AGO   .TRLSE
.RLSE    ANOP
***********************************************************************
**      RELEASE UNUSED SPACE TEXT UNIT                               **
***********************************************************************
         MVI   S99TUKEY+1,DALRLSE      SET TEXT UNIT KEY
         RCPDINC 4
         AGO   .TROUND
.ROUND   ANOP
***********************************************************************
**      RELEASE UNUSED SPACE TEXT UNIT                               **
***********************************************************************
         MVI   S99TUKEY+1,DALROUND     MOVE IN TEXT UNIT KEY
         RCPDINC 4
         MEND
./ ADD NAME=RCPSPEC
         MACRO - SET UP USER DEFINED TEXT UNIT
         RCPSPEC &T
         LCLA  &I,&J
&I       SETA  1
&J       SETA  K'&T
         SPACE
***********************************************************************
**       PROCESS SPECIAL TEXT UNITS                                  **
***********************************************************************
.LOOP    RCPVCHAR &T(&I),&T(&I+2),&T(&I+3),N=&T(&I+1)
&I       SETA  &I+4
         AIF   (&I LE &J).LOOP
         MEND
./ ADD NAME=RCPSR2
         MACRO
         RCPSR2 &A
         GBLB  &RCPSR2
         GBLC  &DYNP
         LCLC  &C
.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY
.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND
.*    GENERATES MOVE INSTRUCTION FOR EXECUTE
         AIF   ('&A' NE '').UNSAVE
         AIF   (&RCPSR2).EXIT
&RCPSR2  SETB  1
         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2
         MEXIT
.UNSAVE  AIF   (NOT &RCPSR2).EXIT
         B     *+10                    SKIP NEXT INSTRUCTION
&C       SETC  '&DYNP.MVC'
&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE
         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2
&RCPSR2  SETB  0
.EXIT    MEND
./ ADD NAME=RCPSSREQ
         MACRO
         RCPSSREQ
         SPACE 1
***********************************************************************
**       SUBSYSTEM REQUEST TEXT UNIT                                 **
***********************************************************************
         SPACE 1
         MVI   S99TUKEY+1,DALSSREQ MOVE IN TEXT UNIT KEY
         RCPDINC                   4
         MEND
./ ADD NAME=RCPSUBL
         MACRO - BREAK DOWN A SUBLIST
         RCPSUBL &L
         GBLA  &RCPSUB#                NO OF ELEMENTS FOUND
         GBLC  &RCPSUBL(100)           ELEMENTS
         LCLA  &I,&J,&K
&RCPSUB# SETA  0                       INITIALIZE
         AIF   ('&L' EQ '').EXIT       EXIT IF NULL STRING
         AIF   ('&L'(1,1) NE '(').NOSUB
&K       SETA  K'&L-1
&I       SETA  2
&J       SETA  1
.LOOP    ANOP
&J       SETA  &J+1
         AIF   (&J  GT &K).LAST
         AIF   ('&L'(&J,1) NE ',').LOOP
&RCPSUB# SETA &RCPSUB#+1
         AIF   (&J EQ &I).NULL
&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)
&I       SETA  &J+1
         AGO   .LOOP
.NULL    ANOP
&RCPSUBL(&RCPSUB#) SETC ''
&I       SETA  &J+1
         AGO   .LOOP
.LAST    AIF   (&J EQ &I).LASTNUL
&RCPSUB# SETA  &RCPSUB#+1
&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)
         AGO   .EXIT
.LASTNUL ANOP
&RCPSUB# SETA  &RCPSUB#+1
&RCPSUBL(&RCPSUB#) SETC ''
         AGO   .EXIT
.NOSUB   ANOP
&RCPSUBL(1) SETC '&L'
&RCPSUB# SETA 1
.EXIT    MEND
./ ADD NAME=RCPSYSOU
         MACRO
         RCPSYSOU &CLASS,&COPIES=,&FREE=,&DEST=,&FORMS=,&FCB=,&CHARS=, X
               &OUTDES=                                     *LBD 11/88*
         GBLC  &DYNP
         LCLC  &C
         AIF   ('&CLASS(1)' EQ '').TPGN
&C       SETC  '&CLASS(1)'
         SPACE
***********************************************************************
**       SYSOUT CLASS TEXT UNIT                                      **
***********************************************************************
         AIF   ('&C'(1,1) EQ '''').Q
         AIF   ('&C'(K'&C,1) EQ '/').BS
         AIF   ('&C'(1,1) EQ '(').REG
         L     R14,&C                  LOAD ADDRESS OF SYSOUT CLASS
         MVC   S99TUPAR(1),0(R14)       AND MOVE IT TO TEXT UNIT
         AGO   .SKEY
.REG     MVC   S99TUPAR(1),0&C         MOVE SYSOUT CLASS TO TEXT UNIT
.SKEY    MVI   S99TUKEY+1,DALSYSOU     SET SYSOUT KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,1            SET LENGTH FIELD
         RCPDINC 8
         AGO   .TPGN
.BS      RCPTUBFR DALSYSOU,14,&C
         AGO   .TPGN
.Q       RCPBTU DALSYSOU,1,&C
.TPGN    AIF   ('&CLASS(2)' EQ '').TCOP
         SPACE
***********************************************************************
**   SYSOUT PROGRAM NAME TEXT UNIT                                   **
***********************************************************************
&C       SETC  '&CLASS(2)'
         RCPVCHAR DALSPGNM,14,&C
.TCOP    AIF   ('&COPIES' EQ '').TFREE
         SPACE
***********************************************************************
**    SYSOUT COPIES TEXT UNIT                                        **
***********************************************************************
         RCPNTU DALCOPYS,1,&COPIES
.TFREE   AIF   ('&FREE' EQ '').TDEST
         SPACE
***********************************************************************
**     FREE = CLOSE TEXT UNIT                                        **
***********************************************************************
         AIF   ('&FREE' EQ 'CLOSE').CLOSEOK
         MNOTE 4,' **** FREE=&FREE INVALID, FREE=CLOSE USED'
.CLOSEOK MVI   S99TUKEY+1,DALCLOSE     MOVE IN TEXT UNIT KEY
         RCPDINC 4
.TDEST   AIF   ('&DEST' EQ '').TFORMS
         SPACE
***********************************************************************
**       SYSOUT DESTINATION TEXT UNIT                                **
***********************************************************************
         RCPVCHAR DALSUSER,14,&DEST
.TFORMS  AIF   ('&FORMS' EQ '').TFCB
         SPACE
***********************************************************************
**     SYSOUT FORMS NUMBER TEXT UNIT                                 **
***********************************************************************
         RCPVCHAR DALSFMNO,14,&FORMS
.TFCB    AIF   ('&FCB' EQ '').TCHARS                        *LBD 11/88*
         SPACE
***********************************************************************
**     SYSOUT FCB NAME TEXT UNIT                                     **
***********************************************************************
         RCPVCHAR DALFCBIM,14,&FCB
.TCHARS  AIF   ('&CHARS' EQ '').TOUTD                       *LBD 11/88*
         SPACE
***********************************************************************
**     SYSOUT CHARS TEXT UNIT                                        **
***********************************************************************
         RCPVCHAR DALCHARS,14,&CHARS                        *LBD 11/88*
         SPACE
.TOUTD   AIF   ('&OUTDES' EQ '').EXIT                       *LBD 11/88*
         SPACE
***********************************************************************
**     SYSOUT OUTPUT JCL STATEMENT REFERENCE TEXT UNIT               **
***********************************************************************
         RCPVCHR2 DALOUTPT,26,&OUTDES                       *LBD 11/88*
.EXIT    MEND
./ ADD NAME=RCPTERM
         MACRO
         RCPTERM
         SPACE
***********************************************************************
**      TERM  DATASET TEXT UNIT                                      **
***********************************************************************
         MVI   S99TUKEY+1,DALTERM      MOVE IN TERM DS TEXT UNIT KEY
         RCPDINC 4
         MEND
./ ADD NAME=RCPTU
         MACRO
         RCPTU &TU            TEXT UNIT LIST
         GBLA  &DTUPO         TEXT UNIT POINTER OFFSET
         GBLC  &DYNP          ALLOC SYMBOL PREFIX
         LCLA  &I,&J
         LCLC  &C
         SPACE 1
***********************************************************************
**       ADD SPECIAL TEXT UNITS                                      **
***********************************************************************
&J       SETA  N'&SYSLIST
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &J).EXIT
         AIF   ('&TU(&I)'(1,1) EQ '(').R
         LA    R15,&TU(&I)             LOAD TEXT UNIT ADDRESS
         ST    R15,&DYNP.TUP+&DTUPO     AND STORE IT IN POINTER LIST
&DTUPO   SETA  &DTUPO+4
         AGO   .LOOP
.R       ANOP
&C       SETC  '&TU(&I)'(2,K'&TU(&I)-2)
         ST    &C,&DYNP.TUP+&DTUPO     STORE TEXT UNIT ADDR IN PTR LIST
&DTUPO   SETA  &DTUPO+4
         AGO   .LOOP
.EXIT    MEND
./ ADD NAME=RCPTUBFR
         MACRO  - BUILD TEXT UNIT FROM BUFFER
         RCPTUBFR &KEY,                TEXT UNIT KEY                   X
               &L,                     MAXIMUM LENGTH VALUE            X
               &C,                     TEXT UNIT                       X
               &N=1                    TEXT UNIT NUMBER
         GBLC  &EXECNAM
         LCLC  &C1,&C2
         LCLA  &I,&K
         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY
         AIF   ('&N' EQ '' OR '&N' EQ '1').N1
         LA    R14,&N                  LOAD TEXT UNIT NUMBER
         STH   R14,S99TUNUM             AND STORE INTO TEXT UNIT
         AGO   .ENDN
.N1      MVI   S99TUNUM+1,1            SET TEXT UNIT NUMBER
.ENDN    ANOP
&K       SETA  K'&C
&I       SETA  &K-1
.LOOP1   ANOP
&K       SETA  &K-1
         AIF   (&K LE 0).STD
         AIF   ('&C'(&K,1) NE '/').LOOP1
&C2      SETC  '&C'(&K+1,&I-&K)
&C1      SETC  '&C'(1,&K-1)
         AIF   ('&C1'(1,1) NE '(').TC2
&C1      SETC  '0&C1'
.TC2     AIF   ('&C2' EQ '0000').V2B
         AIF   ('&C2' EQ '00').V1B
         AIF   ('&C2' EQ '0').V0B
         AIF   ('&C2'(1,1) EQ '(').RL
         MVI   S99TULNG+1,&C2          SET LENGTH FIELD
         MVC   S99TUPAR(&C2.),&C1      MOVE IN TEXT UNIT
         RCPDINC &L
         MEXIT
.STD     ANOP
&K       SETA  &L-6
         MVI   S99TULNG+1,&K           SET TEXT UNIT LENGTH
&C1      SETC  '&C'(1,&I)              REMOVE TRAILING SLASH
         MVC   S99TUPAR(&K),&C1        MOVE IN TEXT UNIT
         RCPDINC &L
         MEXIT
.V2B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH
         S     R14,=A(4)               EXCLUDE LENGTH OF HEADER
&C1      SETC  '4+&C1'
         AGO   .MOVE
.V1B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH
&C1      SETC  '2+&C1'
         AGO   .MOVE
.V0B     SLR   R14,R14                 CLEAR FOR IC
         IC    R14,&C1                 INSERT TEXT UNIT LENGTH
&C1      SETC  '1+&C1'
         AGO   .MOVE
.RL      ANOP
&C2      SETC  '&C2'(2,K'&C2-2)
         LR    R14,&C2                 LOAD TEXT UNIT LENGTH
.MOVE    STH   R14,S99TULNG             AND STORE INTO LENGTH FIELD
         BCTR  R14,0                   GET MACHINE LENGTH
         EXECUTE ,MVC,S99TUPAR-S99TUNIT(0,R15),&C1
         EX    R14,&EXECNAM            MOVE IN TEXT UNIT
         RCPDINC &L
         MEND
./ ADD NAME=RCPTUBFX
         MACRO  - BUILD TEXT UNIT FROM BUFFER
         RCPTUBFX &KEY,                TEXT UNIT KEY                   X
               &L,                     MAXIMUM LENGTH VALUE            X
               &C,                     TEXT UNIT                       X
               &N=1                    TEXT UNIT NUMBER
         GBLC  &EXECNAM
         LCLC  &C1,&C2
         LCLA  &I,&K
         MVC   S99TUKEY,=AL2(&KEY)     SET TEXT UNIT KEY
         AIF   ('&N' EQ '' OR '&N' EQ '1').N1
         LA    R14,&N                  LOAD TEXT UNIT NUMBER
         STH   R14,S99TUNUM             AND STORE INTO TEXT UNIT
         AGO   .ENDN
.N1      MVI   S99TUNUM+1,1            SET TEXT UNIT NUMBER
.ENDN    ANOP
&K       SETA  K'&C
&I       SETA  &K-1
.LOOP1   ANOP
&K       SETA  &K-1
         AIF   (&K LE 0).STD
         AIF   ('&C'(&K,1) NE '/').LOOP1
&C2      SETC  '&C'(&K+1,&I-&K)
&C1      SETC  '&C'(1,&K-1)
         AIF   ('&C1'(1,1) NE '(').TC2
&C1      SETC  '0&C1'
.TC2     AIF   ('&C2' EQ '0000').V2B
         AIF   ('&C2' EQ '00').V1B
         AIF   ('&C2' EQ '0').V0B
         AIF   ('&C2'(1,1) EQ '(').RL
         MVI   S99TULNG+1,&C2          SET LENGTH FIELD
         MVC   S99TUPAR(&C2.),&C1      MOVE IN TEXT UNIT
         RCPDINC &L
         MEXIT
.STD     ANOP
&K       SETA  &L-6
         MVI   S99TULNG+1,&K           SET TEXT UNIT LENGTH
.*&C1    SETC  '&C'(1,&I)              REMOVE TRAILING SLASH
         MVC   S99TUPAR(&K),=C&C       MOVE IN TEXT UNIT
         RCPDINC &L
         MEXIT
.V2B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH
         S     R14,=A(4)               EXCLUDE LENGTH OF HEADER
&C1      SETC  '4+&C1'
         AGO   .MOVE
.V1B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH
&C1      SETC  '2+&C1'
         AGO   .MOVE
.V0B     SLR   R14,R14                 CLEAR FOR IC
         IC    R14,&C1                 INSERT TEXT UNIT LENGTH
&C1      SETC  '1+&C1'
         AGO   .MOVE
.RL      ANOP
&C2      SETC  '&C2'(2,K'&C2-2)
         LR    R14,&C2                 LOAD TEXT UNIT LENGTH
.MOVE    STH   R14,S99TULNG             AND STORE INTO LENGTH FIELD
         BCTR  R14,0                   GET MACHINE LENGTH
         EXECUTE ,MVC,S99TUPAR-S99TUNIT(0,R15),&C1
         EX    R14,&EXECNAM            MOVE IN TEXT UNIT
         RCPDINC &L
         MEND
./ ADD NAME=RCPTXTL
         MACRO - TO COUNT CHARACTERS IN A STRING
         RCPTXTL &S
         GBLA  &RCPTXTL
         LCLA  &I,&K,&L
&RCPTXTL SETA  0
         AIF   (K'&S LT 3).MEND
&RCPTXTL SETA  K'&S-2
&L       SETA  &RCPTXTL
&I       SETA  1
.LOOP    ANOP
&I       SETA  &I+1
.LOOP2   AIF   (&I GT &L).MEND
         AIF   ('&S'(&I,2) NE '''''' AND '&S'(&I,2) NE '&&').LOOP
&I       SETA  &I+2
&RCPTXTL SETA  &RCPTXTL-1
         AGO   .LOOP2
.MEND    MEND
./ ADD NAME=RCPTYPE
         MACRO
         RCPTYPE &T
         GBLC  &RCPTYPE
         LCLA  &I,&K
&K       SETA  K'&T
&RCPTYPE SETC  ''
         AIF   (&K EQ 0).EXIT
&RCPTYPE SETC  'C'
.LOOP    ANOP
&I       SETA  &I+1
         AIF   ('&T'(&I,1) LT '0' OR '&T'(&I,1) GT '9').EXIT
         AIF   (&I LT &K).LOOP
&RCPTYPE SETC  'N'
.EXIT    MEND
./ ADD NAME=RCPUNALC
         MACRO
         RCPUNALC
         SPACE 1
***********************************************************************
**     FREE EVEN IF PERMANENTLY ALLOCATED                            **
***********************************************************************
         MVI   S99TUKEY+1,DUNUNALC     SET TEXT UNIT KEY
         RCPDINC  4
         MEND
./ ADD NAME=RCPUNIT
         MACRO
         RCPUNIT &U,&V
         GBLC  &DYNP
         AIF   ('&U' EQ '').TVOL
         SPACE 1
***********************************************************************
**       UNIT NAME TEXT UNIT                                         **
***********************************************************************
         RCPVCHAR DALUNIT,14,&U
.TVOL    AIF   ('&V' EQ '').EXIT
         SPACE 1
***********************************************************************
**       VOLUME SERIAL TEXT UNIT                                     **
***********************************************************************
         RCPVCHAR DALVLSER,14,&V
.EXIT    MEND
./ ADD NAME=RCPUNITC
         MACRO
         RCPUNITC &CNT
         SPACE
***********************************************************************
**     UNIT ALLOCATION COUNT TEXT UNIT                               **
***********************************************************************
         RCPNTU DALUNCNT,1,&CNT
         MEND
./ ADD NAME=RCPVCHAR
         MACRO
         RCPVCHAR &KEY,&LEN,&C,&N=1
         GBLC  &DYNP
         AIF   ('&C'(K'&C,1) EQ '/').BM
         AIF   ('&C'(1,1) EQ '''').QM
         RCPSR2
         AIF   ('&C'(1,1) EQ '(').RM
         LH    R2,&C+4                 LOAD LENGTH OF TEXT UNIT
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO TEXT UNIT, SKIP
         L     R14,&C                  LOAD ADDRESS OF TEXT UNIT
         AGO   .STHM
.RM      LH    R2,4&C                  LOAD LENGTH OF TEXT UNIT
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO TEXT UNIT, SKIP
         L     R14,0&C                 LOAD ADDRESS OF TEXT UNIT
.STHM    STH   R2,S99TULNG             STORE LENGTH OF TEXT UNIT
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN TEXT UNIT
         MVI   S99TUKEY+1,&KEY         MOVE IN TEXT UNIT KEY
         AIF   ('&N' EQ '1' OR '&N' EQ '').N1
         LA    R14,&N                  LOAD TEXT UNIT NUMBER
         STH   R14,S99TUNUM             AND STORE IT IN TEXT UNIT
         AGO   .ENDN
.N1      MVI   S99TUNUM+1,1            SET NUMBER FIELD
.ENDN    RCPDINC &LEN
         MEXIT
.BM      RCPTUBFR &KEY,&LEN,&C
         MEXIT
.QM      RCPBTU &KEY,&N,&C
         MEND
./ ADD NAME=RCPVCHR2
         MACRO
         RCPVCHR2 &KEY,&LEN,&C,&N=1
         GBLC  &DYNP
         AIF   ('&C'(K'&C,1) EQ '/').BM
         AIF   ('&C'(1,1) EQ '''').QM
         RCPSR2
         AIF   ('&C'(1,1) EQ '(').RM
         LH    R2,&C+4                 LOAD LENGTH OF TEXT UNIT
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO TEXT UNIT, SKIP
         L     R14,&C                  LOAD ADDRESS OF TEXT UNIT
         AGO   .STHM
.RM      LH    R2,4&C                  LOAD LENGTH OF TEXT UNIT
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO TEXT UNIT, SKIP
         L     R14,0&C                 LOAD ADDRESS OF TEXT UNIT
.STHM    STH   R2,S99TULNG             STORE LENGTH OF TEXT UNIT
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN TEXT UNIT
         MVC   S99TUKEY,=AL2(&KEY)     MOVE IN TEXT UNIT KEY
         AIF   ('&N' EQ '1' OR '&N' EQ '').N1
         LA    R14,&N                  LOAD TEXT UNIT NUMBER
         STH   R14,S99TUNUM             AND STORE IT IN TEXT UNIT
         AGO   .ENDN
.N1      MVI   S99TUNUM+1,1            SET NUMBER FIELD
.ENDN    RCPDINC &LEN
         MEXIT
.BM      RCPTUBFR &KEY,&LEN,&C
         MEXIT
.QM      RCPBTU &KEY,&N,&C
         MEND
./ ADD NAME=RCPVOLRT
         MACRO
         RCPVOLRT
         SPACE 1
***********************************************************************
**    VOLUME SERIAL RETURN TEXT UNIT                                 **
***********************************************************************
         MVI   S99TUKEY+1,DALRTVOL     SET RETURN VOLUME SERIAL KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,6            SET LENGTH FIELD
         MVC   S99TUPAR(6),=CL6' '     INITIALIZE FIELD TO BLANKS
         RCPDINC 14
         MEND
./ ADD NAME=S99FAIL
         MACRO
&NAME    S99FAIL &RB=(R14),&RC=(R15),&CPPL=,&MF=G,&CP=
         GBLB  &RCPCPPL(2)             CP INDICATOR
         GBLC  &RCPPRE
         LCLB  &GEN
         LCLC  &C
&NAME    DS    0H
         AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF(1)' EQ 'E').EXEC
         MNOTE 4,'&MF(1) IS AN INVALID MF, MF=G USED'
.GEN     LA    R1,FAIL&SYSNDX     LOAD PLIST ADDRESS
&GEN     SETB  1
         AGO   .L
.EXEC    AIF   ('&MF(2)' NE '').LISTOK
         MNOTE 8,'LIST ADDRESS NOT SPECIFIED'
         MEXIT
.LISTOK  AIF   ('&MF(3)' EQ '').TMF2
&MF(3)   EQU   24                      LENGTH OF PARAMETER LIST
.TMF2    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').L
         AIF   ('&MF(2)'(1,1) EQ '(').REG
         LA    R1,&MF(2)          LOAD DAIRFAIL PARAM LIST ADDRESS
         AGO   .L
.REG     ANOP
&C       SETC  '&MF(2)'(2,K'&MF(2)-2)
         LR    R1,&C              LOAD DAIRFAIL PARAM LIST ADDR
.L       AIF   ('&RB'(1,1) EQ '(').RBR
         AIF   ('&RB' NE '').RBA
         MNOTE 8,'REQ BLOCK ADDRESS NOT SPECIFIED'
         MEXIT
.RBR     ST    &RB(1),0(R1)       STORE S99 RB ADDRESS
         AGO   .RC
.RBA     LA    R14,&RB            LOAD ADDRESS OF REQ BLOCK
         ST    R14,0(R1)          AND STORE IN PLIST
.RC      AIF   ('&RC'(1,1) EQ '(').RCR
         LA    R14,&RC            LOAD ADDRESS OF RET CODE
         ST    R14,4(R1)          AND STORE IN PLIST
         AGO   .EFF02
.RCR     ANOP
.GRC     LA    R14,20(R1)         LOAD ADDR RET CODE FLD
         ST    &RC(1),0(R14)      STORE RET CODE
         ST    R14,4(R1)          AND STORE ITS ADDRESS
.EFF02   LA    R14,=A(0)          LOAD ADDR OF FULLWORD OF 0
         ST    R14,8(R1)          STORE IT.
         AIF   ('&CP' EQ 'YES' OR &RCPCPPL(1)).CPID
         LA    R14,=X'8032'       LOAD ADDRESS OF CALLERID
         ST    R14,12(R1)          AND STORE IT
         XC    16(4,R1),16(R1)    CLEAR CPPL POINTER
         AGO   .GO
.CPID    LA    R14,=Y(50)         LOAD ADDRESS OF CALLERID
         ST    R14,12(R1)         AND STORE IT
         AIF   ('&CPPL' EQ '').DCPPL
         AIF   ('&CPPL'(1,1) EQ '(').RCPPL
         LA    R14,&CPPL          LOAD CPPL ADDRESS
         ST    R14,16(R1)          AND STORE IT
         AGO   .GO
.DCPPL   MVC   16(4,R1),&RCPPRE.CPPL MOVE IN CPPL ADDRESS
         AGO   .GO
.RCPPL   ST    &CPPL(1),16(R1)    STORE ADDRESS OF CPPL
.GO      LINK  EP=IKJEFF18
         AIF   (NOT &GEN).EXIT
         SPACE 1
         RCPDS
&C SETC 'FAIL&SYSNDX'
&C       DS    6F             RESERVE SPACE FOR PARAM LIST
         RCPDS
.EXIT    MEND
./ ADD NAME=TESTOPEN
         MACRO
&NAME    TESTOPEN  &DCB,&BRANCH
&NAME    LA    1,&DCB              REG 1 = DCB ADDRESS
         TM    48(1),X'10'         TEST FOR SUCCESSFUL OPEN.
         AIF   ('&BRANCH' EQ '').NOEXIT
         BZ    &BRANCH             NOT OPEN BRANCH
         MEXIT
.NOEXIT  EQU   *                   OPEN OR NO BRANCH ADDR SPECIFIED
         MEND
